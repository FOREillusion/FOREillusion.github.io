<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PETER TANG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-11T15:15:11.161Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>PETER TANG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>何为技术领导力？</title>
    <link href="http://yoursite.com/2020/08/11/%E4%BD%95%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/08/11/%E4%BD%95%E4%B8%BA%E6%8A%80%E6%9C%AF%E9%A2%86%E5%AF%BC%E5%8A%9B%EF%BC%9F/</id>
    <published>2020-08-11T15:14:57.000Z</published>
    <updated>2020-08-11T15:15:11.161Z</updated>
    
    <content type="html"><![CDATA[<p>何为技术领导力？</p><h1 id="Why-中国的程序员在生存上遇到的问题更多"><a href="#Why-中国的程序员在生存上遇到的问题更多" class="headerlink" title="Why 中国的程序员在生存上遇到的问题更多"></a>Why 中国的程序员在生存上遇到的问题更多</h1><p>中国的基础技术还正在发展中，技术能力不足，所以，目前的状态下，销售、运营、地推等简单快速的业务手段显得更为有效一些，需要比拼的是如何拿到更多的“地”。而西方的“精耕细作”需要比拼的是在同样大小的一块田里，如何才能更快更多地种出“粮食”，这完全就是在拼技术了。</p><ol><li>第一个阶段：野蛮开采。这个阶段的主要特点是资源过多，只需要开采就好了。</li><li>第二个阶段：资源整合。在这个阶段，资源已经被不同的人给占有了，但是需要对资源整合优化，提高利用率。这时通过管理手段就能实现。</li><li>第三个阶段：精耕细作。这个阶段基本上是对第二阶段的精细化运作，并且通过科学的手段来达到。</li><li>第四个阶段：发明创造。 在这个阶段，人们利用已有不足的资源来创造更好的资源，并替代已有的马上要枯竭的资源。这就需要采用高科技来达到了。</li></ol><h3 id="尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。"><a href="#尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。" class="headerlink" title="尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。"></a>尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。</h3><h1 id="什么是技术领导力？"><a href="#什么是技术领导力？" class="headerlink" title="什么是技术领导力？"></a>什么是技术领导力？</h1><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h3 id="解放生产力"><a href="#解放生产力" class="headerlink" title="解放生产力"></a>解放生产力</h3><p>尊重技术，追求核心基础技术。<br>追逐自动化的高效率的工具和技术，同时避免无效率的组织架构和管理。<br>解放生产力，追逐人效的提高。<br>开发抽象和高质量的可以重用的技术组件。<br>坚持高于社会主流的技术标准和要求。</p><ul><li>能够发现问题。能够发现现有方案的问题。</li><li>能够提供解决问题的思路和方案，并能比较这些方案的优缺点。</li><li>能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。</li><li>能够用更优雅，更简单，更容易的方式来解决问题。</li><li>能够提高代码或软件的扩展性、重用性和可维护性。</li><li>能够用正确的方式管理团队。所谓正确的方式，一方面是，让正确的人做正确的事，并发挥每个人的潜力；另一方面是，可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。</li><li>创新能力。能够使用新的方法新的方式解决问题，追逐新的工具和技术。<h2 id="总是在提供解决问题的思路和方案的人才是有技术领导力的人。"><a href="#总是在提供解决问题的思路和方案的人才是有技术领导力的人。" class="headerlink" title="总是在提供解决问题的思路和方案的人才是有技术领导力的人。"></a>总是在提供解决问题的思路和方案的人才是有技术领导力的人。</h2></li></ul><p>扎实的基础技术；<br>非同一般的学习能力；<br>坚持做正确的事；<br>不断提高对自己的要求标准；<br>08/07/2020 23:04</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;何为技术领导力？&lt;/p&gt;
&lt;h1 id=&quot;Why-中国的程序员在生存上遇到的问题更多&quot;&gt;&lt;a href=&quot;#Why-中国的程序员在生存上遇到的问题更多&quot; class=&quot;headerlink&quot; title=&quot;Why 中国的程序员在生存上遇到的问题更多&quot;&gt;&lt;/a&gt;Why 中国的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>会布局的人才是真正的高手</title>
    <link href="http://yoursite.com/2020/08/11/%E4%BC%9A%E5%B8%83%E5%B1%80%E7%9A%84%E4%BA%BA%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%AB%98%E6%89%8B/"/>
    <id>http://yoursite.com/2020/08/11/%E4%BC%9A%E5%B8%83%E5%B1%80%E7%9A%84%E4%BA%BA%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%AB%98%E6%89%8B/</id>
    <published>2020-08-11T15:14:06.000Z</published>
    <updated>2020-08-11T15:14:26.439Z</updated>
    
    <content type="html"><![CDATA[<p>会布局的人才是真正的高手，具备这5大思维，6大素质和10种能力，此生必成大事</p><p>一、五大思维</p><ol><li><p>逆向思维：一般人思考，都是由原因来导向结果，高手的思考是，如何从结果来推导原因。举例：普通人赚钱，是我有什么能力、资源、资金，可以去干什么事。高手赚钱，是我如果要三个月赚一百万，那么需要找到什么能力的人，需要哪些资源，需要多少资金，这些都在谁的手上，如何说服他合作。</p></li><li><p>换位思考：一般人喜欢站在自己的立场思考问题，高手都是站在别人的立场思考问题。举例：普通销售喜欢推销产品给客户，求着客户买单。高手卖产品，是考虑客户的需求在哪里，有什么弱点，然后通过吸引的方式，让客户求着买单。</p></li><li><p>目标思维：普通人做一天和尚，撞一天钟，高手有清晰地目标，知道每天该做什么，里目标越来越近。举例：驴磨磨的时候，一直在换方向，三年过去了，还在原地踏步。千里马瞄准好一个方向，一直往前走，三年后千里马到达了目的地，受到人们称颂。</p></li><li><p>客观思维：实事求是的看待问题，而不是不敢面对现实，反而造成了更严重的情况。举例：某地发生了灾祸，愚蠢的官员会欺上瞒下，自我良好，最后导致灾祸更加严重。智慧的官员，会马上让大众知道，请求上级支援，及时改正错误，造成巨大损失。</p></li><li><p>危机思维：小心驶得万年船，很多成功的人，因为少了忧患的意识，最后一落千丈。举例：阿里巴巴马云在经营公司期间，一直强调公司离倒闭只有18个月，来警醒每一位阿里人，切不可骄傲自满。</p></li></ol><p>二、六大素质</p><ol><li><p>热爱工作：每一位成功人士，都非常的热爱自己的工作，即使到了七八十岁，早已经实现了财富自由，依然会工作在一线。在工作中，只有热爱，才会产生无穷的动力，即使遇到巨大的困难，也会积极的去处理，相信自己一定会获得成功。举例：华为董事长任正非，到了70岁，依然拼搏在一线市场，依然坐飞机全球出差，工作不止，奋斗不息。</p></li><li><p>积极乐观：不管遇到任何的困难，都会积极地去面对，一旦设定好目标，不管多少的艰难险阻，都会坚定自己的信念。相信自己一定能完成，直到最后也不会放弃。举例：历史上朱毛井冈山会师，林彪问毛主席：红旗还能走多久，毛主席积极地回应：星星之火，可以燎原。</p></li><li><p>目标清晰明确：成功者对未来生活，都有清晰的目标，会有详细的目标达成战略，懂得如何去用最快的方式，实现成功。</p></li><li><p>坚韧不拔的毅力：不管遇到什么困难，都会想方设法去逢山开路，遇水搭桥。将一个个困难，当做自我成功的垫脚石，用顽强的斗志去拼搏，知道最后成功。</p></li><li><p>敢于冒险：走出自己的舒适区，不断的去挑战未知的领域，即使得不到别人的理解，既然会继续奋斗，直到成功。</p></li><li><p>精力充沛有良好的作息规律：成功者的自我约束力很强，每天的工作和休息习惯都很规律，永远保持旺盛的精力，源源不断的动力去完成一个又一个目标。</p></li></ol><p>三、五种能力</p><ol><li><p>沟通能力：善于和他人进行良好的沟通，清晰地表达自己的意思，懂得倾听他人，理解他人，并正确的进行回应。</p></li><li><p>适应能力：换了新环境、新工作，会快速的融入进去，在新环境中如鱼得水，在新工作中，快速学习工作需要具备的基本技能。</p></li><li><p>承受能力：承受能力越大，进步越快。现在互联网的高速发展，社会节奏越来越快，如果不能及时跟上时代的步伐，很快就会被淘汰。机遇和挑战并存，不管遇到什么困难，都能化险为夷，抓住一次又一次的机遇。</p></li><li><p>收集资料的能力：互联网上的信信息，多如烟海，学会搜索，找到所需要的一手资料，是每个人都应该必备的生存技能。这会让我们第一时间，了解行业的最新动态，从而快速反应，保持信息的更新。</p></li><li><p>资源整合能力：我们的身边，到处都是资源，只不过懂得利用资源的人很少。只有学会懂得资源整合，我们才能够杠杆借力，让事业十倍速的起步。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会布局的人才是真正的高手，具备这5大思维，6大素质和10种能力，此生必成大事&lt;/p&gt;
&lt;p&gt;一、五大思维&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;逆向思维：一般人思考，都是由原因来导向结果，高手的思考是，如何从结果来推导原因。举例：普通人赚钱，是我有什么能力、资源、资金，可以去干什
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git命令大全</title>
    <link href="http://yoursite.com/2020/08/11/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2020/08/11/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2020-08-11T15:11:50.000Z</published>
    <updated>2020-08-11T15:12:48.645Z</updated>
    
    <content type="html"><![CDATA[<p>git命令大全</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习 Git 命令，发现网上的命令要么排版不清晰，要么不是很全。于是整理出了这篇 Git 命令大全！相信这份 Git 命令，一定值得你收藏。文章内容较多，可以在右侧目录直接找自己需要的部分查看。文章会持续更新，欢迎大家点赞，收藏！</p><p>这里还有一个偷懒的小技巧 hh，如果你不想记住那么多 Git 命令，你可以看看我的这篇文章：VScode 结合 git 的全面使用流程，再也不用记住 git 的命令了！</p><p>VsCode 已经封装好了 Git 命令，我们只要学会怎么使用就好了，是不是很方便呢！</p><p>如果你想学习 Linux 命令，我的另外一篇文章也能帮到你：Linux 命令大全（排版清晰！！持续更新！！非常详细）</p><h2 id="1-Git-安装配置"><a href="#1-Git-安装配置" class="headerlink" title="1.Git 安装配置"></a>1.Git 安装配置</h2><p>在使用 Git 前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac 和 Windows 平台上运行。</p><p>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">http://git-scm.com/downloads</a></p><h3 id="1-1Linux-平台上安装"><a href="#1-1Linux-平台上安装" class="headerlink" title="1.1Linux 平台上安装"></a>1.1Linux 平台上安装</h3><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p><p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p><p>Debian/Ubuntu<br>Debian/Ubuntu Git 安装命令为：</p><p>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext <br>  libz-dev libssl-dev</p><p>$ apt-get install git</p><p>$ git –version<br>git version 1.8.1.2<br>Centos/RedHat<br>如果你使用的系统是 Centos/RedHat 安装命令为：</p><p>$ yum install curl-devel expat-devel gettext-devel <br>  openssl-devel zlib-devel</p><p>$ yum -y install git-core</p><p>$ git –version<br>git version 1.7.1<br>源码安装<br>我们也可以在官网下载源码包来安装，最新源码包下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p><p>安装指定系统的依赖包：</p><p>########## Centos/RedHat ##########<br>$ yum install curl-devel expat-devel gettext-devel <br>  openssl-devel zlib-devel</p><p>########## Debian/Ubuntu ##########<br>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext <br>  libz-dev libssl-dev<br>解压安装下载的源码包：</p><p>$ tar -zxf git-1.7.2.2.tar.gz<br>$ cd git-1.7.2.2<br>$ make prefix=/usr/local all<br>$ sudo make prefix=/usr/local install</p><h3 id="1-2-Windows-平台上安装"><a href="#1-2-Windows-平台上安装" class="headerlink" title="1.2 Windows 平台上安装"></a>1.2 Windows 平台上安装</h3><p>在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：</p><p>安装包下载地址：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p><p>在开始菜单里找到 “Git”-&gt;“Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p><h3 id="1-3Mac-平台上安装"><a href="#1-3Mac-平台上安装" class="headerlink" title="1.3Mac 平台上安装"></a>1.3Mac 平台上安装</h3><p>在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：</p><p><a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">http://sourceforge.net/projects/git-osx-installer/</a></p><p>安装界面如下所示：</p><h3 id="1-4-Git-配置"><a href="#1-4-Git-配置" class="headerlink" title="1.4 Git 配置"></a>1.4 Git 配置</h3><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><p>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。<br>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。<br>当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。<br>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。</p><p>此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><p>用户信息<br>配置个人的用户名称和电子邮件地址：</p><p>$ git config –global user.name “Viper”<br>$ git config –global user.email <a href="mailto:test@Viper.com">test@Viper.com</a><br>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><p>文本编辑器<br>设置 Git 默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:</p><p>$ git config –global core.editor emacs<br>差异分析工具<br>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><p>$ git config –global merge.tool vimdiff<br>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p><p>当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p><p>查看配置信息<br>要检查已有的配置信息，可以使用 git config –list 命令：</p><p>$ git config –list<br>http.postbuffer=2M<br>user.name=Viper<br>user.email=test@Viper.com<br>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。</p><p>这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示：</p><p>vim ~/.gitconfig<br>显示内容如下所示：</p><p>[http]<br>    postBuffer = 2M<br>[user]<br>    name = Viper<br>    email = <a href="mailto:test@Viper.com">test@Viper.com</a><br>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p><p>$ git config user.name<br>Viper</p><h2 id="2-Git-创建仓库"><a href="#2-Git-创建仓库" class="headerlink" title="2.Git 创建仓库"></a>2.Git 创建仓库</h2><p>本章节我们将为大家介绍如何创建一个 Git 仓库。</p><p>你可以使用一个已经存在的目录作为 Git 仓库。</p><p>git init<br>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。</p><p>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p><p>使用方法<br>使用当前目录作为 Git 仓库，我们只需使它初始化。</p><p>git init<br>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为 Git 仓库。</p><p>git init newrepo<br>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><p>$ git add *.c<br>$ git add README<br>$ git commit -m ‘初始化项目版本’<br>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><p>git clone<br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。</p><p>克隆仓库的命令格式为：</p><p>git clone <repo><br>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><p>git clone <repo> <directory><br>参数说明：</p><p><strong>repo:</strong>Git 仓库。<br><strong>directory:</strong> 本地目录。<br>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><p>$ git clone git://github.com/schacon/grit.git<br>执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><p>$ git clone git://github.com/schacon/grit.git mygrit</p><h2 id="3-Git-基本操作"><a href="#3-Git-基本操作" class="headerlink" title="3. Git 基本操作"></a>3. Git 基本操作</h2><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目快照的命令作介绍。</p><h3 id="3-1-获取与创建项目命令"><a href="#3-1-获取与创建项目命令" class="headerlink" title="3.1 获取与创建项目命令"></a>3.1 获取与创建项目命令</h3><p>git init<br>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。</p><p>在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 Viper 项目：</p><p>$ mkdir Viper<br>$ cd Viper/<br>$ git init<br>Initialized empty Git repository in /Users/tianqixin/www/Viper/.git/<br>在 /www/Viper/.git/ 目录初始化空 Git 仓库完毕。<br>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。</p><p>ls -a<br>.    ..    .git<br>git clone<br>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p><p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p><p>git clone [url]<br>[url] 为你想要复制的项目，就可以了。</p><p>例如我们克隆 Github 上的项目：</p><p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:schacon/simplegit.git<br>Cloning into ‘simplegit’…<br>remote: Counting objects: 13, done.<br>remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13<br>Receiving objects: 100% (13/13), done.<br>Resolving deltas: 100% (2/2), done.<br>Checking connectivity… done.<br>克隆完成后，在当前目录下会生成一个 simplegit 目录：</p><p>$ cd simplegit/<br>$ ls<br>README   Rakefile lib<br>上述操作将复制该项目的全部记录。</p><p>$ ls -a<br>.        ..       .git     README   Rakefile lib<br>$ cd .git<br>$ ls<br>HEAD        description info        packed-refs<br>branches    hooks       logs        refs<br>config      index       objects<br>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p><h3 id="3-2-基本快照"><a href="#3-2-基本快照" class="headerlink" title="3.2 基本快照"></a>3.2 基本快照</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。</p><p>git add<br>git add 命令可将该文件添加到缓存，如我们添加以下两个文件：</p><p>$ touch README<br>$ touch hello.php<br>$ ls<br>README        hello.php<br>$ git status -s<br>?? README<br>?? hello.php<br>$<br>git status 命令用于查看项目的当前状态。</p><p>接下来我们执行 git add 命令来添加文件：</p><p>$ git add README hello.php<br>现在我们再执行 git status，就可以看到这两个文件已经加上去了。</p><p>$ git status -s<br>A  README<br>A  hello.php<br>$<br>新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。</p><p>现在我们修改 README 文件：</p><p>$ vim README<br>在 README 添加以下内容：# Viper Git 测试，然后保存退出。</p><p>再执行一下 git status：</p><p>$ git status -s<br>AM README<br>A  hello.php<br>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行 git add 命令将其添加到缓存中：</p><p>$ git add .<br>$ git status -s<br>A  README<br>A  hello.php<br>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。</p><p>git status<br>git status 以查看在你上次提交之后是否有修改。</p><p>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：</p><p>$ git status<br>On branch master</p><p>Initial commit</p><p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</p><pre><code>new file:   READMEnew file:   hello.php</code></pre><p>git diff<br>执行 git diff 来查看执行 git status 的结果的详细信息。</p><p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p><p>尚未缓存的改动：git diff<br>查看已缓存的改动： git diff –cached<br>查看已缓存的与未缓存的所有改动：git diff HEAD<br>显示摘要而非整个 diff：git diff –stat<br>在 hello.php 文件中输入以下内容：</p><?phpecho '菜鸟教程：www.Runoob.com';?><p>$ git status -s<br>A  README<br>AM hello.php<br>$ git diff<br>diff –git a/hello.php b/hello.php<br>index e69de29..69b5711 100644<br>— a/hello.php<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo '菜鸟教程：www.Runoob.com';+?><br>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</p><p>接下来我们来查看下 git diff –cached 的执行效果：</p><p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git diff –cached<br>diff –git a/README b/README<br>new file mode 100644<br>index 0000000..8f87495<br>— /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+# Viper Git 测试<br>diff –git a/hello.php b/hello.php<br>new file mode 100644<br>index 0000000..69b5711<br>— /dev/null<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo '菜鸟教程：www.Runoob.com';+?><br>git commit<br>使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。</p><p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。</p><p>$ git config –global user.name ‘Viper’<br>$ git config –global user.email <a href="mailto:test@Viper.com">test@Viper.com</a><br>接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。</p><p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) d32cf1f] 第一次版本提交<br> 2 files changed, 4 insertions(+)<br> create mode 100644 README<br> create mode 100644 hello.php<br>现在我们已经记录了快照。如果我们再执行 git status:</p><p>$ git status</p><h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><p>nothing to commit (working directory clean)<br>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个 “working directory clean：干净的工作目录”。</p><p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line"># modified:   hello.php</span><br><span class="line">#</span><br></pre></td></tr></table></figure><p>~<br>“.git/COMMIT_EDITMSG” 9L, 257C<br>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p><p>git commit -a<br>我们先修改 hello.php 文件为以下内容：</p><?phpecho '菜鸟教程：www.Runoob.com';echo '菜鸟教程：www.Runoob.com';?><p>再执行以下命令：</p><p>git commit -am ‘修改 hello.php 文件’<br>[master 71ee2cb] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>git reset HEAD<br>git reset HEAD 命令用于取消已缓存的内容。</p><p>我们先改动文件 README 文件，内容如下：</p><h1 id="Viper-Git-测试"><a href="#Viper-Git-测试" class="headerlink" title="Viper Git 测试"></a>Viper Git 测试</h1><h1 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h1><p>hello.php 文件修改为：</p><?phpecho '菜鸟教程：www.Runoob.com';echo '菜鸟教程：www.Runoob.com';echo '菜鸟教程：www.Runoob.com';?><p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：</p><p>$ git status -s<br> M README<br> M hello.php<br>$ git add .<br>$ git status -s<br>M  README<br>M  hello.php<br>$ git reset HEAD hello.php<br>Unstaged changes after reset:<br>M    hello.php<br>$ git status -s<br>M  README<br> M hello.php<br>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。</p><p>$ git commit -m ‘修改’<br>[master f50cfda] 修改<br> 1 file changed, 1 insertion(+)<br>$ git status -s<br> M hello.php<br>可以看到 hello.php 文件的修改并未提交。</p><p>这时我们可以使用以下命令将 hello.php 的修改提交：</p><p>$ git commit -am ‘修改 hello.php 文件’<br>[master 760f74d] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>$ git status<br>On branch master<br>nothing to commit, working directory clean<br>简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。</p><p>git rm<br>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p><p>git rm <file><br>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</p><p>git rm -f <file><br>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可</p><p>git rm –cached <file><br>如我们删除 hello.php 文件：</p><p>$ git rm hello.php<br>rm ‘hello.php’<br>$ ls<br>README<br>不从工作区中删除文件：</p><p>$ git rm –cached README<br>rm ‘README’<br>$ ls<br>README<br>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p><p>git rm –r *<br>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。</p><p>git mv<br>git mv 命令用于移动或重命名一个文件、目录、软连接。</p><p>我们先把刚移除的 README 添加回来：</p><p>$ git add README<br>然后对其重名:</p><p>$ git mv README  README.md<br>$ ls<br>README.md<br>4. 再按照作用重新整理一下命令<br>（这部分命令和上面的有重复，排版的方式不一样）</p><p>一、Git 配置相关<br>如果你首次使用 Git，那刚开始首先是需要配置各种身份信息的，这样当你提交相关任务的时候，别人才能知道这个 commit 是谁提交的。</p><p>Git 最小配置<br>1、配置全局账户，也就是该账户对所有的 Git 仓库都有效</p><p>git config –global user.name ‘你的账户名称’<br>git config –global user.email ‘你的 Email’<br>2、配置局部账户，也就是该账户只对当前 Git 仓库有效</p><p>git config –local user.name ‘你的账户名称’<br>git config –local user.email ‘你的 Email’<br>注意，不同点就是一个参数是 global（全局），一个是 local(本地)</p><p>3、查看相关配置情况</p><p>配置了之后，显然有时候是需要查看我们当前配置的相关情况的，可以使用如下命令</p><p>1、查看 global 类型的配置情况</p><p>git config –global –list<br>2、查看某个仓库下的配置情况</p><p>git config –local –list<br>二、本地基本操作<br>1、基本操作<br>1、查看变更情况</p><p>git status<br>2、查看当前工作在哪个分支上</p><p>git branch -v<br>3、切换到指定分支</p><p>git checkout 指定分支的名称<br>4、把当前目录及其子目录下所有变更都加入到暂存区</p><p>git add . // 注意，add 后面是一个 ‘.’；<br>5、把仓库内所有变更都假如到暂存区</p><p>git add -A<br>6、把指定文件添加到暂存区</p><p>git add 文件1 文件2 … 文件n<br>7、创建正式的 commit，也就是把当前的数据提交上去</p><p>git commit<br>2、比较差异<br>1、比较某文件工作区和暂存区的差异</p><p>git diff 某文件<br>2、比较某文件暂存区和 HEAD 的差异</p><p>git diff –cache 某文件<br>3、比较工作区和暂存区的所有差异</p><p>git diff<br>4、比较暂存区和 HEAD 的所有差异</p><p>git diff –cache<br>3、暂存区与工作区之间回滚<br>1、把工作区指定文件恢复成和暂存区一样</p><p>git checkout 文件1 文件2 … 文件n<br>2、把暂存区指定文件回复和 HEAD 一样</p><p>git reset 文件1 文件2 … 文件n<br>3、把暂存区和工作区所有文件恢复成和 HEAD 一样</p><p>git reset –hard<br>4、用 difftool 比较任意两个 commit 的差异</p><p>git difftool commit1 commit2<br>注意，从工作区回滚到暂存区则用 checkout ，否则用 reset</p><p>4、其他<br>查看哪些文件没有被 Git 管控</p><p>git ls-files –others<br>三、加塞临时任务处理<br>1、把未处理完的变更先保存到 stash 中</p><p>git stash<br>2、临时任务处理完后继续之前的工作</p><p>git stash pop // pop 相当于栈的出栈和入栈一样，把之前的任务弹出来<br>或者<br>git stash apply // 和 pop 不同的是， apply 相当于从栈顶把任务取出来，但是不过从栈中把任务移除<br>3、查看所有的 stash</p><p>git stash list<br>4、取回某次 stash 的变更</p><p>git stash pop stash @{数字n}<br>四、修改个人分支历史<br>我们的仓库的内容每次变更执行 commit 的时候，都会生成一个新的 commit，不过有时候，我们不想产生新的 commit，而是想要通过修改之前的 commit 来变更仓库的内容，那么就可以使用如下命令了</p><p>1、修改最后一次 commit</p><p>1、在工作区中修改文件<br>2、git add<br>3、git commit –amend<br>2|、修改中间的 commit(假设代号为 X)</p><ol><li>git rebase -i X前面的一个 commit 的 id</li><li>在工作区修改文件</li><li>git add</li><li>git rebase –contiue<br>五、查看变更日志等<br>1、当前分支各个 commit 用一行显示</li></ol><p>git log –online<br>2、显示最近的 n 个 commit</p><p>git log -n<br>3、用图示显示所有的分支历史</p><p>git log –online –graph –all<br>4、查看涉及到某文件变更的所有 commit</p><p>git log 某文件<br>5、某文件各行最后修改对应的 commit 以及作者</p><p>git blame 某文件<br>六、分支与标签<br>1、创建新分支<br>基于当前分支创建新分支</p><p>git branch 新分支<br>基于指定分支创建新分支</p><p>git branch 新分支 已有分支<br>基于某个 commit 创建分支</p><p>git branch 新分支 某个 commit 的id<br>创建分支并且切换到该分支</p><p>git chechout -b 新分支<br>2、列出分支<br>列出本地分支</p><p>git branch -v<br>列出本地和远端分支</p><p>git branch -av<br>列出远端所有分支</p><p>git branch -rv<br>列出名称符号某样式的远端分支</p><p>git branch -rv -l ‘某样式’<br>3、删除分支<br>安全删除本地某分支</p><p>git branch -d 要删除的分支<br>强行删除本地分支</p><p>git branch -D 要删除的分支<br>删除已合并到 master 分支的所有本地分支</p><p>git branch –merged master | grep -v ‘^*| master’ | xargs -n 1 git branch -d<br>删除远端 origin 已不存在的所有本地分支</p><p>git remote prune origin<br>4、打标签<br>从 commit 打上标签</p><p>git tag 标签名 commit 的id<br>七、两分支之间的集成<br>1、把 A 分支合入到当前分支，且为 merge 创建 commit</p><p>git merge A分支<br>2、把 A 分支合入到 B 分支，且为 Merge 创建 commit</p><p>git merge A分支 B分支<br>3、把当前分支基于 B 分支做 rebase，以便把 B 分支合入到当前分支</p><p>git rebase B分支<br>4、把 A 分支基于 B 分支做 rebase，以便把 B 分支合入到 A 分支</p><p>git rebase B分支 A分支<br>5、用 mergetool 解决冲突</p><p>git mergetool<br>八、和远端交互<br>1、列出所有 remote</p><p>git remote -v<br>2、增加 remote</p><p>git remote add url地址<br>3、删除 remote</p><p>git remote remove remote的名称<br>4、改变 remote 的 name</p><p>git remote rename 旧名称 新名称<br>5、把远端所有分支和标签的变更都拉到本地</p><p>git fetch remote<br>6、把远端分支的变更拉倒本地，且 merge 到本地分支</p><p>git pull remote名称 分支名<br>7、把本地分支 push 到远端</p><p>git push remote名称 分支名<br>8、删除远端分支</p><p>git push remote –delete 远端分支名<br>或者<br>git push remote:远端分支名<br>9、向远端提交指定标签</p><p>git push remote 标签名<br>10、向远端提交所有标签</p><p>git push remote –tags<br>九、常用回滚操作系统<br>未执行 commit 之前<br>1、如果文件修改了，但是还没有添加到暂存区，也就是还没有执行 git add 操作，则可以使用 checkout 来回滚</p><p>git chechout – filename<br>2、如果已经添加到暂存区，则可以用 reset 来撤销</p><p>git reset HEAD filename<br>执行了 commit 之后<br>1、使用 revert 来撤销某次提交</p><p>git revert commitID<br>// 注：git revert 命令是撤销某次操作，而在此次操作之前和之后的提交记录都会保留<br>2、使用 reset 直接回滚到某个版本</p><p>git  reset –hard  commit_id<br>// –hard – 强制将缓存区和工作目录都同步到你指定的提交<br>这个操作不可逆，会把 commit_id 之后的全部回滚</p><ol start="5"><li>Git 分支管理<br>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</li></ol><p>有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><p>git branch (branchname)<br>切换分支命令:</p><p>git checkout (branchname)<br>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><p>git merge<br>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>开始前我们先创建一个测试目录：</p><p>$ mkdir gitdemo<br>$ cd gitdemo/<br>$ git init<br>Initialized empty Git repository…<br>$ touch README<br>$ git add README<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) 3b58100] 第一次版本提交<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 README<br>5.1 列出分支<br>列出分支基本命令：</p><p>git branch<br>没有参数时，git branch 会列出你在本地的分支。</p><p>$ git branch</p><ul><li>master<br>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。</li></ul><p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。</p><p>如果我们要手动创建一个分支。执行 git branch (branchname) 即可。</p><p>$ git branch testing<br>$ git branch</p><ul><li>master<br>testing<br>现在我们可以看到，有了一个新分支 testing。</li></ul><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><p>$ ls<br>README<br>$ echo ‘Viper.com’ &gt; test.txt<br>$ git add .<br>$ git commit -m ‘add test.txt’<br>[master 3e92c19] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>$ ls<br>README        test.txt<br>$ git checkout testing<br>Switched to branch ‘testing’<br>$ ls<br>README<br>当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。</p><p>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><p>$ git checkout -b newtest<br>Switched to a new branch ‘newtest’<br>$ git rm test.txt<br>rm ‘test.txt’<br>$ ls<br>README<br>$ touch Viper.php<br>$ git add .<br>$ git commit -am ‘removed test.txt、add Viper.php’<br>[newtest c1501a2] removed test.txt、add Viper.php<br> 2 files changed, 1 deletion(-)<br> create mode 100644 Viper.php<br> delete mode 100644 test.txt<br>$ ls<br>README        Viper.php<br>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 Viper.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 Viper.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><p>5.2 删除分支<br>删除分支命令：</p><p>git branch -d (branchname)<br>例如我们要删除 testing 分支：</p><p>$ git branch</p><ul><li>master<br>testing<br>$ git branch -d testing<br>Deleted branch testing (was 85fc7e7).<br>$ git branch</li><li>master</li></ul><p>5.3 分支合并<br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><p>git merge<br>$ git branch</p><ul><li>master<br>newtest<br>$ ls<br>README        test.txt<br>$ git merge newtest<br>Updating 3e92c19..c1501a2<br>Fast-forward<br>Viper.php | 0<br>test.txt   | 1 -<br>2 files changed, 1 deletion(-)<br>create mode 100644 Viper.php<br>delete mode 100644 test.txt<br>$ ls<br>README        Viper.php<br>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</li></ul><p>合并完后就可以删除分支:</p><p>$ git branch -d newtest<br>Deleted branch newtest (was c1501a2).<br>删除后， 就只剩下 master 分支了：</p><p>$ git branch</p><ul><li>master</li></ul><p>5.4 合并冲突<br>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><p>$ git branch</p><ul><li>master<br>$ cat Viper.php<br>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 Viper.php 内容改为:</li></ul><?phpecho 'Viper';?><p>创建 change_site 分支：</p><p>$ git checkout -b change_site<br>Switched to a new branch ‘change_site’<br>$ vim Viper.php<br>$ head -3 Viper.php<br><?phpecho 'Viper';?><br>$ git commit -am ‘changed the Viper.php’<br>[change_site 7774248] changed the Viper.php<br> 1 file changed, 3 insertions(+)<br>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的 (空文件，没有代码)，我们再次修改 Viper.php 文件。</p><p>$ git checkout master<br>Switched to branch ‘master’<br>$ cat Viper.php<br>$ vim Viper.php    # 修改内容如下<br>$ cat Viper.php<br><?phpecho 1;?><br>$ git diff<br>diff –git a/Viper.php b/Viper.php<br>index e69de29..ac60739 100644<br>— a/Viper.php<br>+++ b/Viper.php<br>@@ -0,0 +1,3 @@<br>+<?php+echo 1;+?><br>$ git commit -am ‘修改代码’<br>[master c68142b] 修改代码<br> 1 file changed, 3 insertions(+)<br>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><p>$ git merge change_site<br>Auto-merging Viper.php<br>CONFLICT (content): Merge conflict in Viper.php<br>Automatic merge failed; fix conflicts and then commit the result.</p><p>$ cat Viper.php     # 代开文件，看到冲突内容<br>&lt;?php<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>echo 1;<br>=======<br>echo ‘Viper’;</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>change_site<br>?&gt;<br>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>$ vim Viper.php<br>$ cat Viper.php<br><?phpecho 1;echo 'Viper';?><br>$ git diff<br>diff –cc Viper.php<br>index ac60739,b63d7d7..0000000<br>— a/Viper.php<br>+++ b/Viper.php<br>@@@ -1,3 -1,3 +1,4 @@@<br>  &lt;?php<br> +echo 1;</p><ul><li>echo ‘Viper’;<br>?&gt;<br>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</li></ul><p>$ git status -s<br>UU Viper.php<br>$ git add Viper.php<br>$ git status -s<br>M  Viper.php<br>$ git commit<br>[master 88afe0e] Merge branch ‘change_site’<br>现在我们成功解决了合并中的冲突，并提交了结果。</p><ol start="6"><li>Git 查看提交历史<br>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</li></ol><p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p><p>$ git log<br>commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)<br>Merge: c68142b 7774248<br>Author: Viper <a href="mailto:&#116;&#x65;&#x73;&#116;&#64;&#x56;&#x69;&#112;&#x65;&#114;&#46;&#x63;&#111;&#109;">&#116;&#x65;&#x73;&#116;&#64;&#x56;&#x69;&#112;&#x65;&#114;&#46;&#x63;&#111;&#109;</a><br>Date:   Fri May 3 15:55:58 2019 +0800</p><pre><code>Merge branch &apos;change_site&apos;</code></pre><p>commit c68142b562c260c3071754623b08e2657b4c6d5b<br>Author: Viper <a href="mailto:&#x74;&#x65;&#x73;&#116;&#64;&#86;&#105;&#x70;&#101;&#114;&#46;&#x63;&#x6f;&#109;">&#x74;&#x65;&#x73;&#116;&#64;&#86;&#105;&#x70;&#101;&#114;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Fri May 3 15:52:12 2019 +0800</p><pre><code>修改代码</code></pre><p>commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)<br>Author: Viper <a href="mailto:&#x74;&#101;&#x73;&#116;&#x40;&#x56;&#x69;&#x70;&#x65;&#x72;&#46;&#x63;&#111;&#x6d;">&#x74;&#101;&#x73;&#116;&#x40;&#x56;&#x69;&#x70;&#x65;&#x72;&#46;&#x63;&#111;&#x6d;</a><br>Date:   Fri May 3 15:49:26 2019 +0800</p><pre><code>changed the Viper.php</code></pre><p>commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00<br>Author: Viper <a href="mailto:&#116;&#101;&#x73;&#116;&#x40;&#x56;&#x69;&#112;&#x65;&#x72;&#x2e;&#99;&#111;&#x6d;">&#116;&#101;&#x73;&#116;&#x40;&#x56;&#x69;&#112;&#x65;&#x72;&#x2e;&#99;&#111;&#x6d;</a><br>Date:   Fri May 3 15:35:32 2019 +0800<br>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><p>$ git log –oneline<br>$ git log –oneline<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>c68142b 修改代码<br>7774248 (change_site) changed the Viper.php<br>c1501a2 removed test.txt、add Viper.php<br>3e92c19 add test.txt<br>3b58100 第一次版本提交<br>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the Viper.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add Viper.php</li><li>3e92c19 add test.txt</li><li>3b58100 第一次版本提交<br>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</li></ul><p>你也可以用 –reverse 参数来逆向显示所有日志。</p><p>$ git log –reverse –oneline<br>3b58100 第一次版本提交<br>3e92c19 add test.txt<br>c1501a2 removed test.txt、add Viper.php<br>7774248 (change_site) changed the Viper.php<br>c68142b 修改代码<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><p>$ git log –author=Linus –oneline -5<br>81b50f3 Move ‘builtin-*’ into a ‘builtin/‘ subdirectory<br>3bb7256 make “index-pack” a built-in<br>377d027 make “git pack-redundant” a built-in<br>b532581 make “git unpack-file” a built-in<br>112dd51 make “mktag” a built-in<br>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><p>$ git log –oneline –before={3.weeks.ago} –after={2010-04-18} –no-merges<br>5469e2d Git 1.7.1-rc2<br>d43427d Documentation/remote-helpers: Fix typos and improve language<br>272a36b Fixup: Second argument may be any arbitrary string<br>b6c8d2d Documentation/remote-helpers: Add invocation section<br>5ce4f4e Documentation/urls: Rewrite to accomodate transport::address<br>00b84e9 Documentation/remote-helpers: Rewrite description<br>03aa87e Documentation: Describe other situations where -z affects git diff<br>77bc694 rebase-interactive: silence warning when no commits rewritten<br>636db2c t3301: add tests to use –format=”%N”<br>7. Git 标签<br>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 Viper 项目发布一个 “1.0” 版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0” 的标签。</p><p>-a 选项意为 “创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><p>$ git tag -a v1.0<br>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the Viper.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add Viper.php</li><li>3e92c19 add test.txt</li><li>3b58100 第一次版本提交<br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</li></ul><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><p>$ git tag -a v0.9 85fc7e7<br>$ git log –oneline –decorate –graph</p><ul><li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the Viper.php</li><li>| c68142b 修改代码<br>|/  </li><li>c1501a2 removed test.txt、add Viper.php</li><li>3e92c19 add test.txt</li><li>3b58100 (tag: v0.9) 第一次版本提交<br>如果我们要查看所有标签可以使用以下命令：</li></ul><p>$ git tag<br>v0.9<br>v1.0<br>指定标签信息命令：</p><p>git tag -a <tagname> -m “Viper.com标签”<br>PGP 签名标签命令：</p><p>git tag -s <tagname> -m “Viper.com标签”<br>标签介绍<br>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p><p>所以，标签也是版本库的一个快照。</p><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git 有 commit，为什么还要引入 tag？</p><p>“请把上周一的那个版本打包发布，commit 号是 6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是 v1.2”</p><p>“好的，按照 tag v1.2 查找 commit 就行！”</p><p>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p><p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。</p><p>本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。</p><p>整合步骤<br>1 新建标签<br>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p><p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p><p>而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。</p><p>一般我们都建议使用含附注型的标签，以便保留相关信息；</p><p>当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p><p>2 创建标签<br>[root@Git git]# git tag v1.0<br>3 查看已有标签<br>[root@Git git]# git tag<br>v1.0<br>[root@Git git]# git tag v1.1<br>[root@Git git]# git tag<br>v1.0<br>v1.1<br>4 删除标签<br>[root@Git git]# git tag -d v1.1<br>Deleted tag ‘v1.1’ (was 91388f0)<br>[root@Git git]# git tag<br>v1.0<br>5 查看此版本所修改的内容<br>[root@Git git]# git show v1.0<br>commit 91388f0883903ac9014e006611944f6688170ef4<br>Author: “syaving” &lt;”<a href="mailto:819044347@qq.com">819044347@qq.com</a>“&gt;<br>Date: Fri Dec 16 02:32:05 2016 +0800<br>commit dir<br>diff –git a/readme b/readme<br>index 7a3d711..bfecb47 100644<br>— a/readme<br>+++ b/readme<br>@@ -1,2 +1,3 @@<br>text<br>hello git<br>+use commit<br>[root@Git git]# git log –oneline<br>91388f0 commit dir<br>e435fe8 add readme<br>2525062 add readme<br>8. Git 远程仓库 (Github)<br>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>8.1 添加远程库<br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用, 命令格式如下：</p><p>git remote add [shortname] [url]<br>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> / 注册。</p><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息：</p><p>使用以下命令生成 SSH Key：</p><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“<br>后面的 <a href="mailto:your_email@youremail.com">your_email@youremail.com</a> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。</p><p>回到 github 上，进入 Account =&gt; Settings（账户配置）。</p><p>左边选择 SSH and GPG keys，然后点击 New SSH key 按钮, title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p><p>添加成功后界面如下所示</p><p>为了验证是否成功，输入以下命令：</p><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Hi tianqixin! You’ve successfully authenticated, but GitHub does not provide shell access.<br>以下命令说明我们已成功连上 Github。</p><p>之后登录后点击 “New repository” 如下图所示：</p><p>之后在在 Repository name 填入 Viper-git-test(远程仓库名) ，其他保持默认设置，点击 “Create repository” 按钮，就成功地创建了一个新的 Git 仓库：</p><p>创建成功后，显示如下信息：</p><p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到 GitHub 仓库。</p><p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p><p>$ mkdir Viper-git-test                     # 创建测试目录<br>$ cd Viper-git-test/                       # 进入测试目录<br>$ echo “# 菜鸟教程 Git 测试” &gt;&gt; README.md     # 创建 README.md 文件并写入内容<br>$ ls                                        # 查看目录下的文件<br>README<br>$ git init                                  # 初始化<br>$ git add README.md                         # 添加文件<br>$ git commit -m “添加 README.md 文件”        # 提交并备注信息<br>[master (root-commit) 0205aab] 添加 README.md 文件<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md</p><h1 id="提交到-Github"><a href="#提交到-Github" class="headerlink" title="提交到 Github"></a>提交到 Github</h1><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git<br>$ git push -u origin master<br>以下命令请根据你在 Github 成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的 Github 用户名不一样，仓库名也不一样。</p><p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github 上：</p><p>8.2 查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p><p>git remote<br>实例<br>$ git remote<br>origin<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)<br>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</p><p>8.3 提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><p>git fetch<br>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><p>git merge<br>该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><p>接下来我们在 Github 上点击 “README.md” 并在线修改它:</p><p>然后我们在本地更新修改。</p><p>$ git fetch origin<br>remote: Counting objects: 3, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br>From github.com:tianqixin/Viper-git-test<br>   0205aab..febd8ed  master     -&gt; origin/master<br>以上信息 “0205aab…febd8ed master -&gt; origin/master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：</p><p>$ git merge origin/master<br>Updating 0205aab..febd8ed<br>Fast-forward<br> README.md | 1 +<br> 1 file changed, 1 insertion(+)<br>查看 README.md 文件内容：</p><p>$ cat README.md </p><h1 id="菜鸟教程-Git-测试"><a href="#菜鸟教程-Git-测试" class="headerlink" title="菜鸟教程 Git 测试"></a>菜鸟教程 Git 测试</h1><h2 id="第一次修改内容"><a href="#第一次修改内容" class="headerlink" title="第一次修改内容"></a>第一次修改内容</h2><p>8.4 推送到远程仓库<br>推送你的新分支与数据到某个远端仓库命令:</p><p>git push [alias] [branch]<br>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p><p>$ touch Viper-test.txt      # 添加文件<br>$ git add Viper-test.txt<br>$ git commit -m “添加到远程”<br>master 69e702d] 添加到远程<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 Viper-test.txt</p><p>$ git push origin master    # 推送到 Github<br>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p><p>8.5 删除远程仓库<br>删除远程仓库你可以使用命令：</p><p>git remote rm [别名]<br>实例<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)</p><h1 id="添加仓库-origin2"><a href="#添加仓库-origin2" class="headerlink" title="添加仓库 origin2"></a>添加仓库 origin2</h1><p>$ git remote add origin2 <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git</p><p>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)</p><h1 id="删除仓库-origin2"><a href="#删除仓库-origin2" class="headerlink" title="删除仓库 origin2"></a>删除仓库 origin2</h1><p>$ git remote rm origin2<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)<br>执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin/master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。<br>执行 git merge origin/master 时，它的意思是合并名为 origin/master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。<br>执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin，涉及到远程以及分支，当然也得分开写了。<br>还可以一次性拉取多个分支的代码：git fetch origin master stable oldstable；<br>也还可以一次性合并多个分支的代码：git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290；<br>常见问题</p><p>ssh 访问 gitHub 出错如下：</p><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>The authenticity of host ‘github.com (140.82.118.4)’ can’t be established.<br>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want to continue connecting (yes/no)?<br>Host key verification failed.<br>解决办法：（将 GitHub 添加到信任主机列表后，可以成功访问）</p><p>$ ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</p><h1 id="github-com-22-SSH-2-0-babeld-d45c1532"><a href="#github-com-22-SSH-2-0-babeld-d45c1532" class="headerlink" title="github.com:22 SSH-2.0-babeld-d45c1532"></a>github.com:22 SSH-2.0-babeld-d45c1532</h1><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Warning: Permanently added the RSA host key for IP address ‘140.82.118.4’ to the list of known hosts.<br>Hi earthnorth! You’ve successfully authenticated, but GitHub does not provide shell access.<br>9. Git Gitee<br>大家都知道国内访问 Github 速度比较慢，很影响我们的使用。</p><p>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）。</p><p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p><p>接下来我们学习一下如何使用 Gitee。</p><p>由于我们的本地 Git 仓库和 Gitee 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息。</p><p>1、我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥。</p><p>我们在 Git Github 章节已经生成了自己的 SSH 公钥，所以我们只需要将用户主目录下的 ~/.ssh/id_rsa.pub 文件的内容粘贴 Gitee 上。</p><p>选择右上角用户头像 -&gt; 设置，然后选择 “SSH 公钥”，填写一个便于识别的标题，然后把用户主目录下的 .ssh/id_rsa.pub 文件的内容粘贴进去：</p><p>成功添加后如下图所示：</p><p>接下来我们创建一个项目。</p><p>点击右上角的 + 号，新建仓库：</p><p>然后添加仓库信息：</p><p>创建成功后看到如下信息：</p><p>接下来我们看下连接信息：</p><p>项目名称最好与本地库保持一致。</p><p>然后，我们在本地库上使用命令 git remote add 把它和 Gitee 的远程库关联：</p><p>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>之后，就可以正常地用 git push 和 git pull 推送了！</p><p>如果在使用命令 git remote add 时报错：</p><p>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>fatal: remote origin already exists.<br>这说明本地库已经关联了一个名叫 origin 的远程库，此时，可以先用 git remote -v 查看远程库信息：</p><p>git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (push)<br>可以看到，本地库已经关联了 origin 的远程库，并且，该远程库指向 GitHub。</p><p>我们可以删除已有的 GitHub 远程库：</p><p>git remote rm origin<br>再关联 Gitee 的远程库（注意路径中需要填写正确的用户名）：</p><p>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>此时，我们再查看远程库信息：</p><p>git remote -v<br>origin    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (fetch)<br>origin    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (push)<br>现在可以看到，origin 已经被关联到 Gitee 的远程库了。</p><p>通过 git push 命令就可以把本地库推送到 Gitee 上。</p><p>有的小伙伴又要问了，一个本地库能不能既关联 GitHub，又关联 Gitee 呢？</p><p>答案是肯定的，因为 git 本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以 Viper-test 本地库为例，我们先删除已关联的名为 origin 的远程库：</p><p>git remote rm origin<br>然后，先关联 GitHub 的远程库：</p><p>git remote add github <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git<br>注意，远程库的名称叫 github，不叫 origin 了。</p><p>接着，再关联 Gitee 的远程库：</p><p>git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>同样注意，远程库的名称叫 gitee，不叫 origin。</p><p>现在，我们用 git remote -v 查看远程库信息，可以看到两个远程库：</p><p>git remote -v<br>gitee    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (fetch)<br>gitee    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (push)<br>github    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (fetch)<br>github    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (push)<br>如果要推送到 GitHub，使用命令：</p><p>git push github master<br>如果要推送到 Gitee，使用命令：</p><p>git push gitee master<br>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p><p>10.Git 服务器搭建<br>上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p><p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p><p>接下来我们将以 Centos 为例搭建 Git 服务器。</p><p>1、安装 Git<br>$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>$ yum install git<br>接下来我们 创建一个 git 用户组和用户，用来运行 git 服务：</p><p>$ groupadd git<br>$ useradd git -g git<br>2、创建证书登录<br>收集所有需要登录的用户的公钥，公钥位于 id_rsa.pub 文件中，把我们的公钥导入到 / home/git/.ssh/authorized_keys 文件里，一行一个。</p><p>如果没有该文件创建它：</p><p>$ cd /home/git/<br>$ mkdir .ssh<br>$ chmod 755 .ssh<br>$ touch .ssh/authorized_keys<br>$ chmod 644 .ssh/authorized_keys<br>3、初始化 Git 仓库<br>首先我们选定一个目录作为 Git 仓库，假定是 / home/gitrepo/Viper.git，在 / home/gitrepo 目录下输入命令：</p><p>$ cd /home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo/<br>$ cd gitrepo</p><p>$ git init –bare Viper.git<br>Initialized empty Git repository in /home/gitrepo/Viper.git/<br>以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以. git 结尾。然后，把仓库所属用户改为 git：</p><p>$ chown -R git:git Viper.git<br>4、克隆仓库<br>$ git clone <a href="mailto:git@192.168.45.4">git@192.168.45.4</a>:/home/gitrepo/Viper.git<br>Cloning into ‘Viper’…<br>warning: You appear to have cloned an empty repository.<br>Checking connectivity… done.<br>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p><p>这样我们的 Git 服务器安装就完成。</p><p>总结<br>这篇 Git 命令并不是特别的全，不过日常使用也基本能够满足了。如果有什么错误，麻烦各位在评论区指正，看见后会修改的。感觉文章不错的话点个收藏，关注我，持续更新不同高质量文章！</p><p>全文完<br>本文由 简悦 SimpRead 优化，用以提升阅读体验<br>使用了 全新的简悦词法分析引擎 beta，点击查看详细说明<br>前言<br>1.Git 安装配置<br>1…1Linux 平台上安装<br>Debian/Ubuntu<br>Centos/RedHat<br>源码安装<br>1.2 Windows 平台上安装<br>1.3Mac 平台上安装<br>1.4 Git 配置<br>用户信息<br>文本编辑器<br>差异分析工具<br>查看配置信息<br>2.Git 创建仓库<br>git init<br>使用方法<br>git clone<br>3. Git 基本操作<br>3.1 获取与创建项目命令<br>git init<br>git clone<br>3.2 基本快照<br>git add<br>git status<br>git diff<br>git commit<br>git reset HEAD<br>git rm<br>git mv<br>4. 再按照作用重新整理一下命令<br>一、Git 配置相关<br>二、本地基本操作<br>4、其他<br>三、加塞临时任务处理<br>四、修改个人分支历史<br>五、查看变更日志等<br>六、分支与标签<br>七、两分支之间的集成<br>八、和远端交互<br>九、常用回滚操作系统<br>5. Git 分支管理<br>5.1 列出分支<br>5.2 删除分支<br>5.3 分支合并<br>5.4 合并冲突<br>6. Git 查看提交历史<br>7. Git 标签<br>标签介绍<br>整合步骤<br>1 新建标签<br>2 创建标签<br>3 查看已有标签<br>4 删除标签<br>5 查看此版本所修改的内容<br>8. Git 远程仓库 (Github)<br>8.1 添加远程库<br>8.2 查看当前的远程库<br>实例<br>8.3 提取远程仓库<br>8.4 推送到远程仓库<br>8.5 删除远程仓库<br>实例<br>9. Git Gitee<br>10.Git 服务器搭建<br>1、安装 Git<br>2、创建证书登录<br>3、初始化 Git 仓库<br>4、克隆仓库<br>总结<br>共计：32030 个字符，汉字：9161，段落：1102，英文单词：3932</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git命令大全&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在学习 Git 命令，发现网上的命令要么排版不清晰，要么不是很全。于是整理出了这篇 Git 命令大全！相信
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防范gsm短信嗅探</title>
    <link href="http://yoursite.com/2020/06/22/%E9%98%B2%E8%8C%83gsm%E7%9F%AD%E4%BF%A1%E5%97%85%E6%8E%A2/"/>
    <id>http://yoursite.com/2020/06/22/%E9%98%B2%E8%8C%83gsm%E7%9F%AD%E4%BF%A1%E5%97%85%E6%8E%A2/</id>
    <published>2020-06-22T06:41:18.600Z</published>
    <updated>2020-06-22T14:52:38.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「防不了」的新型盗刷方式：GSM-短信嗅探详解-少数派"><a href="#「防不了」的新型盗刷方式：GSM-短信嗅探详解-少数派" class="headerlink" title="「防不了」的新型盗刷方式：GSM 短信嗅探详解 - 少数派"></a>「防不了」的新型盗刷方式：GSM 短信嗅探详解 - 少数派</h1><p><a href="https://sspai.com/post/46020" target="_blank" rel="noopener">From</a>June 22, 2020</p><p>关于信息安全，我们似乎觉得，只要自己不「作」，就不会「翻车」：平时不无脑点击各种来路不明的链接、不随便将验证码告知他人，不法分子便对我们无可奈何。</p><p>然而，最近一种新的盗刷方式却刷新了我们的理解——<strong>不用用户点击任何链接，甚至在用户没有察觉的情况下，就能轻松获得手机上的验证码，盗取用户支付宝，微信，网银中的资产。</strong></p><p><img src="https://cdn.sspai.com/minja/2018-08-06-1.png" alt="img"></p><p>事件介绍 事件介绍目前为止几个受害人经历都非常相似：从凌晨的某个时间开始手机就不断收到各种验证码短信，一般从支付宝的登录验证码开始，接着是修改支付宝支付密码，再然后就是银行卡各种转出，消费和贷款。</p><p>这里是部分受害人相关的微博文章和动态：</p><p>最重要的是，与普通的盗刷方式不同，<strong>所有受害人都没有点击未知链接，也没有主动将验证码之类的敏感信息转发给任何人，甚至大部分受害人都是在早上起床才发现被人在凌晨盗刷。</strong></p><p>这实在是刷新了我们的理解，难道不法分子的技术已经能够直接远程操控手机了吗？答案并不完全对，其实这个技术还不是那么新，这几个受害人碰到的不法分子，使用的都是一种可以远程获取手机信息的方式：<strong>GSM 短信嗅探（GSM Sniffing）</strong>。</p><p>这是一种什么方式？为啥最近突然出现？危害性如何？我们自身如何才能防范这种类型的攻击？接下来我就给大家一一分析。</p><p>GSM 短信嗅探原理拦截手机信号，分析其中的短信和通话内容。这听起来像是电影之中的剧情，但是其实做到这一点没有想象中那么难。</p><p>我们都知道，手机作为一种无线设备，必须通用基站进行数据交换。无论是 2G，3G 还是 4G 网络，手机和基站之间本质都是通过无线电波进行通讯，而无线电波是向四周扩散的，理论上只要在手机功率发射电波的范围内的任何设备都可以接收到这些无线电波。</p><p><img src="https://cdn.sspai.com/2018/08/06/5d2df36035db36efa53b0d4b8a4ffbe3.jpg" alt="img"></p><p>而基站和手机之间约定的无线电波接收方法和格式就是通信协议。在国内：</p><ul><li><strong>4G</strong> 协议就是我们经常在状态栏上看到的 LTE（OFDM，UWB），它的好处除了我们能够感受到的网速快和延时低外，还有一个特别重要的优点：支持 VoIP 方式通话，也就是我们打电话时语音数据不仅可以走 4G 通道，也可以借助有线和无线网络传输，摆脱对移动信号的依赖。</li><li><strong>3G</strong> 用的是 UMTS/WCDMA/TD-SCDMA，这个时期各家运营商的制式都不大相同，缺乏一个统一的标准，而且相比 2G 来讲 3G 创新的点并不多，速度也不能满足当时的需求。</li><li><strong>2G</strong> 网络使用的，就是今天的罪魁祸首 —— GSM 协议。<strong>2G 网络架构是开源的，它本身传输数据时也没有加密，这就导致短信内容是明文传输的</strong>1 ，这就给不法分子提供了可乘之机。</li><li></li></ul><p>因为现在 2G 网络并没有完全被淘汰，所以干坏事儿的门槛就断崖式降低了。</p><p>在硬件上，不法分子们经常改装的手机摩托罗拉 C118 在网上便宜到只要十几块钱就能买到一台，加上数据线等材料和工具，犯罪成本总共算下来也不过几十块钱。</p><p>而软件上，他们也不再需要专业人士的帮助。只要借助  即可，它的全称为 Open Source Mobile Communications Baseband，是从硬件层到应用层彻彻底底开源的 GSM 协议实现项目，<strong>它的出现让人无需学习复杂的网络通讯和通讯设备的硬件知识，就能在 GSM 协议里面按照自己的需求随意更改，添加功能。</strong>GSM 嗅探就是添加的功能之一。</p><p>实践上，不法分子只需要将修改过后的 OSMOCOMBB 编译进随便一台手机里面，软硬件结合，<strong>手机就可以变成一台反向获取附近基站发出的无线电波的设备</strong>，再加上一台电脑就可以轻松获取到周围空气中飞奔的短信内容。</p><p>关于这方面的相关教程甚至被定义为「新手难度」，还很容易就能搜索到（数量可以说达到泛滥的地步了……）。</p><p>提示：为了避免模仿犯罪，本文提到的原理和科普均隐去技术细节与详细内容。</p><p><img src="https://cdn.sspai.com/minja/2018-08-06-3.png" alt="img"></p><p>有了这套设备后，不法分子的犯罪流程就容易理解了：</p><ol><li><strong>地点随机，时间深夜</strong>：随机挑选一个地点作为目标，带着伪基站和修改好的 OSMOCOMBB 手机半夜过去。之所以大部分类型盗刷都发生在半夜，是因为这个时候大部分人都在睡觉，给不法分子操作时间最长，而且用户不能即使发现止损。</li><li><strong>获取号码，登录网站</strong>：使用伪基站获取附近手机的手机号码，然后拿着号码请求登录普通网站。</li><li><strong>过滤数据，验证号码</strong>：过滤 OSMOCOMBB 手机获取到的数据，如果拿到了网站发出的验证码即表明号码有效。</li><li><strong>号码有效，开始盗刷</strong>：接下来就是消费支付宝银行卡里面的钱，如果用户在一些网站上做过手持身份证验证，不法分子还可以登陆这些网站拿到手机主人的名字，身份证号和手持身份证照片。有了这些，大额贷款也可以申请了。</li><li></li></ol><p><strong>这个过程，从头到尾都不需要受害人参与。</strong></p><p>为什么最近才开始出现众多受害者既然 GSM 嗅探利用的是 2G 协议的漏洞，不是什么新的东西，那为什么直到最近几天才「搞了个大新闻」呢？</p><p>其实，这项攻击技术在很多年前就已经开始有人尝试。但是由于以下 2 个原因并没有成为一种流行的攻击方式：</p><ol><li><strong>以前技术门槛更高</strong>：当时硬件成本和编译方法还没有像如今一样简单，这提高了准入门槛。直到 Github 上开源的嗅探项目越来越多也越来越 「小白」，才有更多的不法分子采用这种方法（千万别高看他们的文化水平，有能力自己修改 GSM 项目的人不会用它来犯罪）。</li><li><strong>以前实名制范围不够广</strong>：那时候还没有实名制，所以大部分服务都没有强制绑定手机号码，大多数用户依旧采用邮箱登录。</li><li><strong>以前在线支付尚未普及</strong>：加之网络支付和网银等在那时普及度不高，所以获得短信内容的意义不是很大。<strong>这种方法主要还是私家侦探等用于窃听私人信息。</strong></li></ol><p>最近正值运营商废除 2G 之时，众多 GSM 嗅探的受害人想必也会加快运营商废除 2G 网络的速度。虽然 3G，4G 也有类似的攻击方法，不过其难度将大大提升。</p><p><img src="https://cdn.sspai.com/2018/08/06/9bcbfac47d18b53e1064bc0e53e4bca5.jpeg" alt="img"></p><p> 谁该背锅与局限性至于这个锅就要扔到 GSM 不加密和手机验证码登录身上，手机验证码登录本身就是一个很不安全的验证方式，现在<strong>短信验证码能够做到的东西（转账，实名等）已经远远超出了它本身安全性的范围</strong>。</p><p>另外，虽然 GSM 嗅探听起来很吓人，但是这也不代表不法分子可以为所欲为，它也是有自己的缺点的。</p><ul><li><strong>距离限制</strong>：不法分子只有在受害者手机在其基站附近才能实现嗅探，距离被严重限制。不过，如果不法分子提高成本，购买高性能天线的话则可以延长嗅探距离。</li><li><strong>形式限制</strong>：这种方法只能获取短信验证码，所以只能做和短信验证码有关的事。如果用户的个人信息保护地非常好那么不法分子能做的事情就少了很多（U 盾等实体二步认证硬件就是为了防范这种攻击）。</li><li></li></ul><p>当然这些缺点也不妨碍 GSM 嗅探成为最近危害性最大的攻击手段之一。</p><p>应对方法说实话，面对这种绕过用户的攻击手段普通用户还真的没有太有效的防范方法。这里我只能总结几条除了保护好个人信息、报警之类车轱辘话以外比较有效的方法。</p><ul><li><strong>手机定时开关机/飞行模式：</strong>晚上睡觉前关机或者打开飞行模式，这样手机不会连到伪基站，基站获取不到手机的状态信息就不会将验证码短信发送给手机，不法分子获取不到手机号码和验证码短信。</li><li><strong>警惕信号好的地方掉 2G 网络：</strong>这种攻击需要借助 2G 网络，有时候不法分子会用伪基站让手机掉到 2G 来拦截语音短信和联网数据。当你的手机在平时信号很好的地方突然掉到 2G 就要小心附近是不是有伪基站和 GSM 嗅探了。</li><li><strong>设置手机不会掉到 2G 网络：</strong>用户可以在网络设置里面设置为只使用 3G，4G 网络。这样子的缺点是不支持 4G VoLTE 的手机会打不了也接不了电话，相当于自爆。当然如果手机还不支持 4G 或是 VoLTE 功能也该换了，否则别说 GSM 嗅探了，连伪基站攻击都防不了。</li><li><strong>开通 VoLTE</strong>：开通之后加上手机支持，电话和短信都是走 4G 通道，不会使用 2G 网络。例如移动用户就可以发送 <code>KTVOLTE</code> 到 10086 开通 VoLTE；联通用户可以发送 <code>VBNCDGFBDE</code> 到 10010 开通。不过即使这样也防不了不法分子会用伪基站让手机掉到 2G，<strong>需结合前面两点使用</strong>。</li><li><strong>专门使用一个手机号接收验证码</strong>：可以先准备一台手机，双卡手机的话可以准备一张手机卡，专门用于接收验证码短信。这个手机或这张卡平时可以不开机或者禁用。这种方法虽麻烦但也许是目前最有效的。</li><li><strong>使用二步验证</strong>：支持二步验证的网站，也可以打开网站应用的两步验证。让对方仅凭手机号也验证码没办法进入你的账户。</li><li><strong>受到损失后及时报警查看附近监控</strong>：如果是看教程自己改手机那种小毛贼的话，也许能通过附近监控找到，但是如果是惯犯或者对于拿着巨型天线扫描的专业组织就没办法了。</li><li></li></ul><p>最后想补一句，因为电信在 2G 使用的协议是 CDMA，所以可以天然免疫 GSM 嗅探这种攻击方式。</p><p>结语随着运营商退 2G 行动的完成，这种攻击方法也会渐渐成为历史，以后一定会有新的攻击方法代替它，到时候我依然会第一时间给大家出谋划策。喜欢这篇文章可以在少数派关注我（fairyex），我们下次再见。</p><p><img src="https://cdn.sspai.com/2018/08/06/cb28deb10db6d0da663b5023854542a0.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;「防不了」的新型盗刷方式：GSM-短信嗅探详解-少数派&quot;&gt;&lt;a href=&quot;#「防不了」的新型盗刷方式：GSM-短信嗅探详解-少数派&quot; class=&quot;headerlink&quot; title=&quot;「防不了」的新型盗刷方式：GSM 短信嗅探详解 - 少数派&quot;&gt;&lt;/a&gt;「防不
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu</title>
    <link href="http://yoursite.com/2020/05/21/ubuntu/"/>
    <id>http://yoursite.com/2020/05/21/ubuntu/</id>
    <published>2020-05-21T13:30:16.841Z</published>
    <updated>2020-05-21T13:31:25.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu完全教程，让你成为Ubuntu高手！"><a href="#Ubuntu完全教程，让你成为Ubuntu高手！" class="headerlink" title="Ubuntu完全教程，让你成为Ubuntu高手！"></a>Ubuntu完全教程，让你成为Ubuntu高手！</h1><p><strong>Ubuntu的发音</strong><br>Ubuntu， 源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too  的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词  who 或者 boo ，重音在第二个音节即 u’buntu ，oo-boon-too  。如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声：  oom-boon-too。Ubuntu的中文发音大约为： <strong>乌班图</strong></p><h3 id="1-Ubuntu的涵义"><a href="#1-Ubuntu的涵义" class="headerlink" title="1.Ubuntu的涵义"></a>1.Ubuntu的涵义</h3><p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。</p><h3 id="2-Ubuntu的特点"><a href="#2-Ubuntu的特点" class="headerlink" title="2.Ubuntu的特点"></a>2.Ubuntu的特点</h3><p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。<br>Ubuntu  社区恪守 Ubuntu  理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。 自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。<br>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。<br>Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。<br>Ubuntu相对其它Linux发行版的主要特点：<br>1.基于Debian/Linux：使用 APT 包管理系统。<br>2.相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级<br>3.相对于Debian：软件更新积极，而Debian较保守。<br>4.相对于Gentoo：基本无需编译，省力、省时、省心。</p><p><strong>进入系统</strong><br>在 登录界面中输入您的用户名，然后系统将提问您的密码，输入您的密码后，回车，稍事等待，您便可以进入Ubuntu系统，点击桌面左上角的图标，您可以打开 一个菜单（或者使用 Alt+F1  组合键），如果您想退出系统，可以点击该图标，在桌面上方启动栏中，包含了一些常用程序的启动图标这些图标也可以在开始菜单中找到，现在点击 FireFox图标，您便可以使用FireFox浏览器冲浪，或者按下 Alt+F2 组合键，弹出一个运行命令对话框。输入 firefox  后回车，同样可以启动FireFox，菜单中找到 终端，点击它便开启了一个终端窗口，您可以在终端窗口中运行命令，也可以在控制台中输入命令。使用  Ctrl+Alt+[F1<del>F6] ，您可以切换到1</del>6号控制台，使用 Ctrl+Alt+F7  可以返回图形界面（您可以使Ctrl+Alt+BackSpace 将图形界面关闭）</p><h1 id="命令行提示符"><a href="#命令行提示符" class="headerlink" title="命令行提示符"></a>命令行提示符</h1><p>user@ubuntu:~$ 为命令提示符， @ 之前的部分为当前用户ID， @ 与 : 之间的部分，为您的主机名称， : 与 $ 之间的部分，为当前的路径。</p><h1 id="退出系统"><a href="#退出系统" class="headerlink" title="退出系统"></a>退出系统</h1><p>您可以点击这一个图标来退出系统<br>也可以在终端或者控制台中输入命令<br>sudo halt<br>系统会提问您密码，输入正确密码，便可以退出系统<br>在以后的章节中，如果我们提示您输入命令，那么您即可以在终端中输入，也可以在控制台中输入。如果只是启动应用程序，还可以使用 Alt+F2 组合键。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>分区概念<br>首先我们需要知道，硬盘分区的存在，是由硬盘的物理特性决定的，并不会因为不同的操作系统而有所改变。<br>请您把一块硬盘想象为一本书……即便您不喜欢读书，您也一定非常熟悉它，所有的书都是相同的，包括我们使用的课本……您肯定非常熟悉<br>一本完整的书，通常包括书名、索引和正文。<br>如果您需要Linux，您首先需要找到一本书名为《linux》的书，书名相当于硬盘中的MBR，也就是主引导纪录。不同的是，MBR可以是几个书名合在一起，类似于《XX合订本》。这部分内容暂时还没有什么实用价值，您只需要大概的了解。<br>而正文，就是硬盘中纪录的数据，这也非常容易理解，且对于安装系统并没有什么影响，所以现在我们来了解索引<br>索引相当于硬盘中的分区表，书中的每一个章节，相当于硬盘中的一个分区，它起始和结束的页次，都可以在索引中找到。试想，如果阅读一本撕掉索引的书，您将很难找到您想阅读的部分。同样，如果没有分区表，操作系统也不能够在硬盘上定位数据的位置。<br>由于历史的原因，硬盘中的分区表大小受到了限制，最多只可以容纳四个分区（主分区）。如果一本书，它的索引最多只能有四个章节，那不是太可怕了么？很多书的内容远远不止四个章节啊！<br>于是聪明的人们想到了一个变通的办法，就是利用其中的一个章节，来存储其它部分的索引。比如第一章是前言，第二章是其它部分的索引，我们翻到第二<br>章，呵呵，这里是第二个索引，因为只有第一个索引受四个章节的限制，所以这个索引的内容可以非常的详尽。第二个索引就是分区表中的扩展分区了，其中定义的<br>章节，就是硬盘中的逻辑分区，不是很难理解吧？<br>明白了这一点，我们来看看Linux和Windows对于分区不同的表示方法：<br>可能您已经很熟悉Windows了，它使用盘符来表示分区，比如 C: D: E:<br>，每一个分区使用一个盘符来标识，而且顺序可以颠倒， D:<br>并不一定就是您系统中的第二个分区。（如果您给第二个分区分配最后一个硬盘盘符，把所有的盘符按顺序排列好，并且重装一次系统，您就会理解什么叫作“头<br>疼”了：）<br>而在Linux中，分区是这样表示的<br>/dev/hda                /dev/hda1           /dev/hda2               /dev/hda5/             dev/sdb1<br>以 /dev/hda5 为例:<br>因为在Linux中，每一个设备都是用 /dev/ 文件夹下的一个文件来表示，所以 /dev/hda5 中， /dev/ 表示的是根目录下的dev目录，我们来看剩下的部分 hda5 。<br>前两位的字母 hd 表示这是一块IDE硬盘，如果是 sd ，则代表SATA硬盘，或者闪存等外设。<br>第三位的字母 a 表示这是该类型接口上的第一个设备。同理， b、c、d…… 分别代表该类型接口上的第二三四……个设备。例如 hdc 表示第二个IDE接口上的主硬盘（每个IDE接口上允许一个主设备和一个从设备）。<br>第 四位的数字  5，并不表示这是该硬盘中的第5个分区，而是第一个逻辑分区。因为在Linux中，为了避免不必要的混乱，分区的顺序是不能改变的，分区标识则由它们在硬 盘中的位置决定。系统又要为所有可能的主分区预留标识，所以 1-4 一定不会是逻辑分区， 5 则是第一个逻辑分区，以此类推。</p><h1 id="安装中的注意事项"><a href="#安装中的注意事项" class="headerlink" title="安装中的注意事项"></a>安装中的注意事项</h1><p>在Ubuntu系统的安装过程中，您需要选择系统目录的挂载点。<br>我 们知道，安装Windows时，我们可以选择把系统安装在哪一个分区，把系统挂载到分区上。而在buntu/Linux中则相反，我们要把分区挂载到系统 中。当我们使用Windows的安装方式，把系统挂载到分区上，我们就不可能把Windows目录放在C盘，而把MyDocuments目录放到其它分 区。您或者出于习惯，或者出于数据安全方面的考虑，通常把文档放到其它分区中。但是Windows下很多软件保存文件的默认目录就是MyDocument 目录，这就比较不方便。<br>在系统安装完成后，我们还是可以将MyDocuments目录转移到其它分区中，不过有点麻烦，可能许多朋友还不知 道怎么去作……而任何一种Linux系统时，当然包括Ubuntu，我们可以在系统安装时就把分区挂载到目录下， /home  目录相当于Windows的MyDocuments ，我们可以把 /dev/hda5 挂载到此目录下，这样我们往  /home目录里存东西的时候，其实保存在第一个扩展分区中。如果再一次安装系统，只要把这个分区挂载到  /home目录下，那么进入新系统就像回家一样，真是太棒了。<br>理论上来讲，您可以将分区挂载到任何目录下面，您可以自定义挂载的路径。但是我们并不推荐您这么作，因为那没有任何意义。系统安装程序向您建议的挂载目录，通常也是我们向您建议的，现在我们来了解一下，这些目录通常都是用来作什么的：<br><strong>/</strong>根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下，有2G的容量应该是够用了。当然了，很多东西都是多多益善的：）<br><strong>Swap</strong>交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量只要大于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。<br><strong>/home</strong>前面已经介绍过了，这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区<br><strong>/usr</strong>应用程序目录。大部分的软件都安装在这里。如果您计划安装许多软件，建议您也给它分配一个分区<br><strong>/var</strong>如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区<br><strong>/boot</strong>如果您的硬盘不支持LBA模式（我想那不太可能:），您最好挂载它，如果挂载硬盘的第一个分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了<br>在文件系统这一环节中，我们建议您选择： ReiserFS<br>也许您注意到了，Windows中，盘符既用于表示硬件（硬盘上的分区）,又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径，不会混淆在一起，简单直接！<br>Linux基础</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>可能您早已能够熟练的使用GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。<br>我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。<br>这一套GUI系统，便是一种Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了：）<br>易于上手、界面直观是GUI的优点，但是GUI为不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。<br>我的Windows系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类的程序启动管理器，效果还是差强人意。<br>在 我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出  运行对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行  cs命令，就可以去维护世界和平了。<br>这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在D盘建立了一个名为  path的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在  D:\path目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要示我帮他们设定这种启 动方式，因为这确实很方便：）<br>其实在Linux下，所有的程序都可以通过命令运行。虽然Linux也有GUI，但是它并不比Windows的GUI更优秀！上面只是简单的介绍了CLI（命令行界面）相对GUI的优越之处，使用CLI还有更多的好处，您会慢慢体会到的。<br>当然了，在您的印象中，CLI一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和CLI之间甚至有代沟的存在：）</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。<br>也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！<br>其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：<br>command path/file<br>如果只有一个以 c 起始的命令，键入 c ，再按一次 tab 键，系统将自动补全该命令余下的部分。 只要 c tab 两次按键，就可以完成 command 的输入。<br>如果不只一个 c 起始的命令，那么您可以按两次 tab 键，系统会列出所有符合条件的选项，也就是以 c 起始的所有命令。进一步输入 o ，如果只有一个以 co 起始的命令（一直输入，直到项符合条件的选项唯一），再按一次 tab ，命令就被补全完整。<br>路径和文件名也可以通过 tab 键来补全。还有一种 遍历补全 的方式，如果您的文件名是中文，而您不想切换输入法；甚至您的文件名中出现乱码，无法输入，这时 遍历补全 就可以大显身手了。这部分内容我们稍后再谈：）<br>现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。<br>我们知道，任何语言都有特定的语法结构，以我们的中文为例：<br>我们郑重地推荐您Ubuntu/Linux！<br>这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：<br>我们<br>主语，Linux命令的执行者只有一个，所以主语一概省略。<br>推荐<br>一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入 date 命令，您可以查看当前的时间日期。（ 应用程序-&gt;附件-&gt;终端 ）<br>郑重的<br>状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 – 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟参数。<br>您 Ubuntu/linux<br>这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)<br>分隔符<br>我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。<br>cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）<br>上面的那句话，翻译成Linux的命令，应该是这个样子的：<br>推荐 –郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“–”后跟完整单词的参数。不过也有例外：）<br>哈，Linux的命令也蛮简单吧？</p><h1 id="Linux程序、进程"><a href="#Linux程序、进程" class="headerlink" title="Linux程序、进程"></a>Linux程序、进程</h1><p>或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我怎么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑……<br>其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用参数来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整参数，并不是很方便。<br>举一个例子：<br>mplayer -shuffle -loop 3 -playlist mymp3.list<br>可 能您运行上面命令，系统会提示您  无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用 mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行;也可以通过执行命令来运行它的命令行版本。<br>如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，请参阅 软件安装 。<br>上 面命令中， mplayer 调用了mplayer播放器程序。参数 -shuffle 表示随机播放， -loop 表示循环播放，后面的3  为循环的次数，如果为 0 ,则一直播放。 -playlist 表示播放列表中的曲目。我们可以把mp3的路径放到  mymp3.list文件中，让mplayer来播放它们。<br><strong>进程</strong>为运行中的程序，是程序在内存中的镜像。<br>好了，现在您已经了解了 Shell 、 命令 、 程序 、 进程 的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解：）。<br>但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。</p><h1 id="Linux系统简介"><a href="#Linux系统简介" class="headerlink" title="Linux系统简介"></a>Linux系统简介</h1><p>路径<br>路径分为绝对路径和相对路径。<br>绝对路径的起始点为根目录 / ，例如 /usr/local/bin 就是绝对路径，它指向系统中一个绝对的位置，不受其它因素影响。<br>相对路径的起始点为当前目录，如果您现在位于 /usr 目录，那么相对路径 local/bin 所指示的位置为 /usr/local/bin<br>也 就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录 /bin 、 /usr/bin、  /usr/local/bin ，如果只有一个相对路径 bin，那么它指示的位置可能上面三个目录中的任意一个，也可能是其它目录。<br>如果我告诉您到 bin 目录寻找一个文件，您可能搞不清楚是哪一个 bin 目录。只有当前位置确定，相对路径指示的位置才能够确定。<br>现在我说， /usr/local 目录下，它的相对路径 bin 中有某个文件，这样就比较明确了。<br>在相对路径中 . 表示当前目录， .. 表示当前目录的上一级目录。<br>假设您安装了一个程序，它的主程序没有被放置到上面三个 bin 目录中的任何一个，或者其它系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。<br>可以使用绝对路径，例如： /home/user/bin/可执行文件<br>或者定位到 /home/user/bin 目录，使用相对目录来定位它 ./可执行文件<br>如果您定位到了它的子目录，比如 /home/user/bin/gui，您可以使用 .. 来表示它的上级目录 ../可执行文件<br>路径相关命令<br>cd (change directory) 更改目录。<br>pwd (print working directory)显示当前路径。<br>ls (list) 显示当前目录中的文件列表。<br>请尝试以下操作：<br>cd /etc 进入“/etc”目录，这里使用的是绝对路径<br>pwd 显示当前路径，这个命令返回结果“/etc”<br>cd init.d 进入“/etc”目录的子目录“init.d”，这里使用的是相对路径<br>cd .. 进入上一级目录“/etc”<br>cd ../home “/etc” 目录的上一级目录为“/”，它的子目录“home”为“/home”<br>cd - 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回到“/etc”目录<br>cd ~ “~”代表当前用户的“$HOME”目录，也就是“/home/{用户名}”目录。<br>ls 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。<br>远程路径：<br>远程路径的表示方法为 协议://用户名:密码@位置/路径:端口<br>大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写。例如：<br><a href="http://www.ubuntu.org.cn/.../index.html" target="_blank" rel="noopener">http://www.ubuntu.org.cn/.../index.html</a><br>要求身份验证的远程路径，您可以使用下面的方式访问:<br><a href="ftp://user:passwd@ftp.ubuntu.org.cn:21" target="_blank" rel="noopener">ftp://user:passwd@ftp.ubuntu.org.cn:21</a><br>软件<br>Linux中没有<strong><em>注册表</em></strong>这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。<br>按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。<br><strong>Bin</strong>可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。<br><strong>Etc</strong>配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。<br><strong>Lib</strong>库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。<br><strong>Share</strong>程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。<br>还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样作。<br>* 执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样 /home/user/bin/可执行文件 ，不够方便。<br>* 许多系统软件需要协作运行，配置文件分别保存，定位它们非常麻烦<br>* 如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。<br>有一些大型软件，或者您布署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式，将在 软件安装 部分介绍）<br>配置方式<br>Linux下没有类似 注册表 的系统，系统和软件都可以通过纯文本的配置文件进行设置。<br>事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部作成菜单，想象一下……开始发抖吧……<br>图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如 Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本占用的时间，直接修改配置文件甚至更迅速。<br>如果只是要修改某一常用选项，而且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。<br>图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定……这时，您可以使用命令行的配置工具来完成这些工作。<br>例如： 修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：<br>ifconfig eth0 192.168.0.1<br>在以后的章节中，如果我们提示您修改某一文件，例如 /etc/fstab ，您可以使用任何顺手的文本编辑器打开它。<br>隐藏文件<br>Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来，<br>您可以尝试以下操作：<br>cd ~ 进入您的用户目录<br>ls 查看当前目录下的文件列表<br>ls -a 查看所有文件的文件列表（包括隐藏文件）。<br>现在，您可以看到许多文件名以 . 起始的文件或者文件夹了吧？使用 ls 命令无法显示它们<br>* 如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用 ls 命令的参数 -A （ls -A）<br>* 每个目录下都包含两个特殊目录 . 和 .. 。您也许猜到了， . 代表当前目录， .. 代表上一级目录。目录是一种特殊类型的文件！</p><h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。<br>现在使用 ls -l 命令，查看详细信息格式的文件列表，您将会看到如下内容：<br>total 5<br>drwxr-x— 4 user group 4096 Mar 10 00:37 filename<br>drwxr-xr-x 21 user group 4096 Mar 10 20:16 文件名<br>-rw——- 1 user group 524 Mar 10 00:40 a<br>-rw-r–r– 1 user group 24 Jun 11 2000 b<br>drwx—— 2 user group 4096 Mar 9 11:06 c<br>共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称<br>其中要特别留意的是第一列：<br>drwxr-xr-x<br>一共有10个位置，可以分为4组：<br>d      rwx   r-x   r-x<br>第一组只有一个字符：<br><em>* d文件夹\</em> -普通文件* l链接* b块设备文件* c字符设备文件。*<br>剩下的3组分别为归属用户、归属群组、其它用户或群组对于该文件的权限。我们看它的格式<br>rwx rwx   rwx<br><em>* r可读\</em> w可写* x可执行*<br>它们的顺便不能颠倒，某一位置为空(-)，则表示不具有相应的权限。<br>说明：Linux下的可执行文件并不是由扩展名（例如 .exe ）决定的，而是由其可执行权限位决定。<br>权限<br>我们已经知道了，文件的权限分为 r （可读）、 w （可写）、 x （可执行）三种类型，而一个文件可以针对归属用户，归属群组，其它用户用户或群组分别设定权限。<br>这种权限管理的方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。<br>使用 chmod 命令更改文件的权限，使用 chown 来更改文件的归属。例如：<br>chmod 755 xxx<br>chmod a+x xxx<br>chown user:group xxx 用来更改文件的归属用户，也可以同时更改其归属群组<br>chgrp group xxx 用来更改文件的归属群组<br>上面命令中的 755 和 a+x 是两种类型的表达式<br>我们将后面章节中详细介绍 权限管理 用户管理<br>执行命令的权限<br>有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？<br>例如在系统中增加一个新用户 useradd<br>ls -l /usr/sbin/useradd<br>可以看到：<br>-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd<br>明明所有的用户都可以执行嘛？<br>这是因为， useradd 命令是修改 /etc/passwd 文件的一个工具，来看看这个文件：<br>ls -l /etc/passwd<br>-rw-r–r– 1 root root 1835 2006-06-24 17:58 /etc/passwd<br>原来只有root用户才能写入修改结果，非root用户执行 useradd 命令当然不会有结果。<br>执行命令的身份<br>默认情况下，您的命令提示符末位为 $ ，这表示您将以普通用户的身份执行命令。<br>您可以使用 su （switch user）这个命令来切换其它用户。<br>例如 su root ，切换到root用户，如果 su 命令后面没有切换目标，那么这个命令默认切换到root用户。<br>现在您执行 su 这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末位变成了 # ，您将以root用户的身份执行命令。<br>Ubuntu系统默认会随机设定系统的root密码，这样会更安全一些，这个时候您可以执行“sudo”命令，输入当前用户密码后，暂时以root<br>用户的身份执行命令。（前提是sudoer列表中要包含您的ID。您在安装Ubuntu系统时创建的用户，默认具有“sudo”权限）<br>如果您能够执行“sudo”命令，那么您也就拥有了root权限。在后面的章节中，如果我们提到了“root权限”，那么您可以通过以上两种方式来实现<br>命令行<br>Shell、Console、Terminal<br>在前面的章节中，我们曾提到，电视机的遥控器，也是一种人机交互的界面，算是一种Shell。<br>但是这个概念并不准确，遥控器只是向Shell发送指令的工具，Shell接收到遥控器发出指令后，将指令转换为系统命令，由系统来执行。<br>例如我们按的遥控器上的 数字键1 ,遥控器将 切换为1频道 的指令发送到Shell，Shell将指令转换为系统可以识别的 频道1 ，系统执行它，您就可以观看1频道的电视节目了。<br>通 常每台电视机只有一种Shell，比如有的电视机系统具有“画中画”的功能，那么Shell中便有相应的功能定义，您可以通过遥控器上的“画中画”功能键 来开启它。假设您的电视机没有此功能，Shell中也就没有相应的功能定义。拥有一个带“画中画”功能控制键的遥控器，即便信号兼容，您还是不能够使用这 一功能：）<br>不用遥控器也可以控制电视机，假设您的遥控器丢了，您还可以走到电视机前，使用机身上的控制面板来控制它（相当于使用Linux的控制台）。但是您一定不喜欢这种方式，除非您想锻炼身体：）<br>在Linux系统中，由于图形界面和控制台的分辨率通常不一致，所以切换时要有一个延时。对于我们中文用户来讲，控制台下中文的显示也比较麻烦。而且控制台显示内容通常不如终端显示的全面。<br>所以我们推荐您使用终端来执行命令，它使用起来感觉很像遥控器：）<br>rxvt-unicode<br>通 常情况下，您买一台电视机，只能获得一个遥控器。虽然它为您的电视机量身定作，能够最大限度发挥电视机的能力，但您却不一定喜欢它。说不定这个遥控器体形 太大，持握不方便;或者它体形太小，容易失踪;又或者它的按键要么太硬，要么太软;它的键盘要么太大，要么太小……您一般也可以容忍，毕竟遥控器使用频率 并不算高：）<br>如果您的终端有些地方不讨您喜欢，比如说响应太慢，或者不能正常显示中文……那就难以忍受了，您应该换一个其它的试试。<br>在前面的章节，我们介绍您使用的终端为Gnome-Termianl，它是系统默认使用的终端，显示中文不错，不过响应比较慢，您可能已经处于水深火热之中了。。。<br>我们推荐您使用urxvt（mlterm也是不错的选择）<br>您可以使用 sudo apt-get install rxvt-unicode 命令来安装它。<br>urxvt 启动它 （urxvt不支持控制台，您得在图形界面下启动它。终端、Alt+F2，建议您在启动栏里新建一个启动图标）<br>rxvt-unicode还支持“服务器/客户端”的运行模式：<br>urxvtd 启动一个守护进程daemon（支持控制台）<br>urxvtc 启动客户端client。多个客户端可以同时连接到一个urxvtd，以达到节省系统资源的目的。<br>或许您对rxvt的默认设置不满意，您可以修改用户配置文件 <del>/.Xresources 来设定它。修改全局配置文件 /etc/X11/Xresources/Xresources ，则对所有用户生效，只有root才可以修改此文件。<br>这里有一些简单的选项：（以 ! 起始的行是注释，您可以直接拷贝此文件的内容）<br>!!=============================================================================<br>!! RXVT-unicode setting<br>!!=============================================================================<br>!设置字体分辨率<br>Xft.dpi:96<br>!窗口大小<br>Rxvt.geometry: 80x40+80+80<br>!颜色<br>Rxvt.background:#333333<br>Rxvt.foreground:antiquewhite<br>Rxvt.inheritPixmap:False<br>Rxvt.colorBD:yellow<br>Rxvt.colorUL:antiquewhite<br>!滚动条<br>Rxvt.scrollBar:True<br>Rxvt.scrollBar_left:True<br>Rxvt.scrollBar_floating:False<br>Rxvt.scrollstyle:next<br>Rxvt.scrollColor:#999999<br>!屏幕缓冲<br>Rxvt.saveLines:30000<br>Rxvt.color12:DodgerBlue<br>Rxvt.font:7x14,xft:AR PL New Sung<br>!输入法一般设置为xim<br>!inputMethod:xim;Scim除外<br>!输入法样式可选:Root(置底) OverTheSpot(跟随) OffTheSpot OnTheSpot，后两种不是所有的都支持<br>Rxvt.preeditType:Root<br>Tip：右键点击启动栏， 添加自启动器 ， 自定义程序 ，便可以在添加自己的启动图标。<br>在线帮助系统<br>您可以使用命令 man 或者 info 来阅读Linux命令的在线文档。命令的格式非常简单：<br>man xxx<br>大部分命令手册为英文版，如果您的英文不太好，或许有些困难。在后面的 系统管理 章节中，我们会尽力向您介绍命令的使用方法。<br>说明：在使用“man”浏览器的时候，一些快捷键您可能会用到：<br>Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页<br>Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页<br>/ 查找 q(uit) 退出<br>以上为VI风格的键绑定。您也可以使用Emacs风格的键绑定<br>bash<br>好了，现在我们换了一个遥控器，感觉顺手多了。现在来操练一下，下载一首mp3：<br>我们使用 wget 这个程序，它非常可靠，完全值得您信赖。<br>首先找到一个可以下载的地址，复制链接，在终端窗口内点击鼠标中键，把它粘贴进去。<br>现在终端中大概是这种情形：<br><a href="http://www.download.net/xxx.mp3" target="_blank" rel="noopener">http://www.download.net/xxx.mp3</a><br>按下 Ctrl+a 组合键，我们发现光标移动到了行首。输入 wget 和 空格<br>wget <a href="http://www.download.net/xxx.mp3" target="_blank" rel="noopener">http://www.download.net/xxx.mp3</a><br>回车后，终端中出现一些信息，不一会儿工夫，mp3便下载完成。<br>使用 Ctrl+a 组合键，我们就不需要使用方向键来移动光标，方向键每次只能移动一个字符，没有效率<br>您还可以使用 Ctrl+f 向前移动光标， Ctrl+b 向后移动光标， Ctrl+e 将光标移动到行末……………… （键绑定）<br>Note<br>Linux的图形界面中，鼠标中键通常执行“粘贴”的操作，如果您的鼠标没有中键，您可以左右键同时按下。<br>中止正在运行的程序<br>如果一个命令持续时间很长，以致于不能够进行其它操作，可以使用 Ctrl+c 来强行中止它。<br>Ctrl+s<br>出于意外，有时您会按下 Ctrl+s 这个组合键，Shell便被冻结。尝试使用 Ctrl+q 组合键，看能否恢复正常。<br>键绑定<br>等等，有必要记这么多快捷键么？都这么复杂！<br>我 们强烈建议您记住，以大幅度的提高操作效率。而且这是readline控件的键绑定，在任何使用readline控件的程序中，您都可以使用它们。例如 bash、lftp、gdb等程序;同时，Linux下最著名的Emacs编辑器，也是这种风格的键绑定（其实是readline使用了Emacs风格的 键绑定才对），甚至FireFox中，也可以使用类似风格的快捷键！（Linux下主要有两种风格的键绑定，一种是VI风格，另一种是Emacs风格，我 们会在 简明VIM教程中介绍）<br>现在列举一些ReadLine的键绑定，您可以自行尝试。（运行 man readline 命令，来查看ReadLine手册）<br>先来了解一些约定：<br>\C-a 表示 Ctrl+a<br>\M-a 表示 Meta+a Meta键在PC中通常为ALT键<br>A 表示 Shift+a<br>（下面括号中的\A代表Alt，\S代表Shift）<br>移动命令：<br><em>\C-a移动到行首Aheah               \C-e移动到行末End                   \C-f向前移动一个字符Forward</em><br><em>\C-b向后移动一个字符Backward               \M-f向前移动一个单词\M-b向后移动一个单词</em><br><em>\C-l清空屏幕cLear这两个命令也可以理解为移动命令\C-p上翻，前一条命令Previous</em><br><em>\C-n下翻，后一条命令Next编辑命令：</em><br><em>\C-d删除光标后的一个字符\M-d删除光标后的一个单词Delete</em><br><em>\BackSpace删除光标前的一个字符\M-BackSpace删除光标前的一个单词</em><br><em>\C-k删除光标至行末的部分Kill                  \C-u删除光标至行首的部分Unix-line-discard</em><br><em>\C-w删除光标前的一个单词Word              \C-y粘贴（最后删除的对象）Yank            \C–撤消</em><br>搜索历史纪录：<br><em>\C-r连续使用<code>C-r</code>可以查找下一个\M-p           \M-n</em><br>补全：<br><em>\Tab使用频率最高的功能！\C-o遍历补全（未定义）</em><br><em>\M-? M-=列出所有可能选项，相当于按两次Tab键（M-？实际按键为\A+\S+/）</em><br><em>\M-#注释掉当前命令，用于将当前命令暂存于历史纪录列表（\A+\S+3）</em><br><em>\M-!补全命令，通常用来补全子命令，例如<code>sudo</code>的子命令（\A+\S+1）</em><br>*\M-</del>补全用户名（\A+\S+<code>）\M-@补全主机名（\A+\S+2）**\M-$补全变量（\A+\S+4）\M-_补全历史纪录中的纪录（\A+\S+-）**\M-\*将所有可能选项放到命令行中（\A+\S+8）*自定义键绑定通过修改 /etc/inputrc 文件，可以更改键绑定。建议您使用默认的键绑定，以避免不必要的烦恼。当然了，Emacs风格的键绑定是通用的，随时都有可能用到。在文件中添加该行，可以将ReadLine的键绑定设为VI风格。（Bash、Lftp等使用ReadLine的软件同时生效）set editing-mode vi找到这一行：$if mode=emacs在它的下面添加如下内容&quot;\C-o&quot;: menu-complete\###这两行不是必须的，视情况而定###&quot;\c-p&quot;: non-incremental-reverse-search-history&quot;\c-n&quot;: non-incremental-forward-search-history重新登录Shell，您就可以使用 \C-o （Ctrl+o）来遍历补全。假如您的文件名为中文，或者出现乱码时，您可以使用 \M-*将所有文件名放入命令行，再删除多余的，这真是麻烦极了！所以您可以使用 \C-o 遍历补全，将所有可能的选项轮流放入命令行。或者使用Vim编辑器编辑 /etc/inputrc 文件，在插入模式下使用 Ctrl+v 组合键。按下 Ctrl+o ，这时编辑区新增一个 ^O 字符，等价于 \C-o通配符使用 ? 代表任意单个字符。例如 ???lo ，表示 lo 前有三个字符，它可以匹配 Hello使用 * 代表随意几个任意字符。例如 *.iso ，代表所有iso格式的文件。说明：您可以将遍历补全和通配符结合使用，以提高效率。例如：cd */ 则遍历补全只补全文件夹chmview *.chm 则遍历补全只补全chm文件任务管理&amp;--------------------------------在命令的末尾加上一个 &amp; 符号，表示背景任务，例如：wget http://www.download.net/xxx/mp3 &amp;;----------------------------------使用 ; 将多个命令连结起来，则表示任务按顺序执行&amp;&amp;------------------------------使用 &amp;&amp; 将多个命令连结起来，则表示只有前面的命令执行成功，后面的命令才能得以执行``-----------------------------------</code>&lt;命令&gt;<code>，如果一个命令中包含以 ``  （Esc键下方的按键）括起来的子命令，那么子命令将被优先执行，执行结果被代入上一级命令继续执行，例如创建一个以当前时间命名的文件：touch</code>date +%m.%d_%H:%M:%S<code>touch 命令能够创建一个文件，它的操作对象，为 date +%m%d%H%M%S 命令的输出 06.06_06:06:60这样，我们创建了一个名为 06.06_06:06:60 的文件（六月六日六时六分刚过六十秒-_-!）Ctrl+z将当前Shell中的任务挂起这个时候任务的状态为[1]+ Stopped xxxBg-------------------------------------------------将挂起的任务背景运行。这时它的状态为[1]+ xxx &amp;Fg-------------------------------------------------将背景任务调到前台执行jobs方括号中的数字为命令的任务编号，您可以使用 jobs 命令来查看所有背景任务如果后台运行多个任务，您可以在 bg 或者 fg 后跟任务编号，作为操作对象，例如：bg 2管道、重定向\&gt;-----------------------重定向符号，它的作用是将命令的输出重定向到一个文件中。比如我们想把命令 ls 的结果保存为 FileList 文件，作一个清单，我们可以使用重定向符号来完成它：ls -l &gt; FileList\&gt;&gt;----------------------作用与 &gt; 基本相同，不同点在于， &gt;&gt; 以追加的方式，将命令的输出写入文件的末尾。&lt;-----------------------是从文件到命令的重定向，将文件的内容作为命令的输入。|------------------------ 为管道符号，它的作用是将前一个命令的输出，作为下一个命令的输入。假设一个目录下的文件太多，使用 ls命令不能够在屏幕中完全显示，这个时候您可以将  ls 命令的输出，通过管道符号，作为浏览器 less 的输入。就可以使用浏览器的功能翻页、查找：ls -al | less说明： less 浏览器的键绑定几乎与 man 相同，请参阅 在线帮助系统脱字符Shell中的一些功能是通过特殊符号作为控制字符来实现的，上面已经介绍了很多了。这产生一个问题，如果一个文件名中，刚好包含了这些字符，比如 ; ，就很难对它进行操作。使用 less 浏览这个文件less ;xxxless 会很快返回一个错误信息，因为并没有一个文件名作为操作对象。接着，Shell会报告，系统中没有 xxx 这个命令。这是因为Shell将文件名中的 ; 解析为按顺序执行命令。或者您的文件名以空白起始，而在Shell中，无论多少个空格，都将被解析为一个分隔符。您甚至不是使用命令重命名此文件。这个时候就要用到脱字符 \ 了，它能够将一个具有特殊涵义的字符转换普通字符。上面的两个任务，可以在文件名中每个特殊字符前加一个 \ ，像这样less \;xxxless \ \xxxless \;\ \&amp;\xxx说明：也可以使用 &quot; 将文件名括起来，例如 less &quot;; &amp;xxx&quot; ，在很多情况下，这样甚至更方便。脱字符在Shell中也可以作为换行符，在一个命令的末尾添加一个 \ ，然后回车，在下一行继续输入命令剩余的部分，将一个命令拆分为多行且不影响它的执行（如果执行一个很长的命令，请将它拆分为多行以便于阅读）事实上换行符也符合脱字符的定义。回车键有两个涵义，一个是 执行 （Enter），另一个 换行 （折线箭头）。在Shell中它作为控制字符 执行 ，使用脱字符后，它便代表排版字符 换行 了。Fishthe friendly interactive shell正如它的名字，Fish是一款非常友好的Shell，大力推荐！使用命令 sudo apt-get install fish 安装它。完成后，运行命令 fish 切换到fish， exit 返回bash。简单介绍一下它的优点：***1.自动补全、语法高亮***bash的自动补全默认只是补全命令、路径，如果想补全变量、参数等，通常需要使用复杂的组合键（见上面bash的介绍），即便您能够记住它们，快速准确的按下这些组合键，也是一种严峻的考验。而FISH的自动补全可以自动识别语法，补全正确的内容。并且具有语法高亮的功能，比如用MPLAYER放MP3：mpl(ayer) -l(oop) (0)-sh(uffle) -pl(aylist) (mp3_playlist)一阵猛按  键，一个蛮长的命令就完成了。补全结果不唯一时给出的提示中含有简短的说明，这样通常也不用看帮助了：）比如：mplayer -l 后，自动将参数补全为 -lo 然后给出提示-{lo}adidx (Load index from file) -{lo}op (Loop playback) {花括号中为青色文字}它的语法高亮功能十分有用，如果你输入的命令是正确的，则用青色显示，正确的参数用白色显示，错误的则一律用红色。***2.方便的历史纪录搜索***还是上面的那个命令mplayer -loop 0 -shuffle -playlist mp3_playlist用上翻配合下翻浏览命令历史，直到找到这个命令，当然那样太慢了。还可以输入以上命令中的某一部分，如 uffle 只要翻一次就可以找到了（还可以META＋上翻在已输入部分中插入某一历史单词）***3.文件夹历史纪录***dirh （dir history）就可以显示当前会话中进入的文件夹纪录使用 prevd 和 nextd 跳转假如曾进入过1 2 3 4 5 这几个文件夹， prevd 4 可以让你在 5 中直接跳到 1***4.其它的功能***fish基本是兼容bash的。键绑定也非常的相似，少数的键绑定不尽一致，例如：\C-h 删除光标前的一个字符（bash为退格键，不方便）修改 /etc/fish_inputrc 这个文件，增加以下行：&quot;\C-n&quot;: history-search-forward&quot;\C-p&quot;: history-search-backward现在使用Ctrl+p上翻，使用Ctrl+n下翻。如果已经在命令行中输入字符，那么Ctrl+p就是在历史纪录向上查找您输入的字符，Ctrl+n为向下查找，非常的方便。设定您的默认Shell如果能够拥有root权限，可以直接修改 /etc/passwd 文件。找到您用户ID起始的行user:x:1000:112:user,,,:/home/user:/bin/bash最后一个字段为登录后的默认Shell， /bin/bash 是程序 bash 的主程序路径。 fish 主程序的路径通常为 /usr/bin/fish 。/etc/shells 中列出系统中所有可用Shell（ /bin/false 代表禁用Shell）也可以使用如下命令更改您的默认Shellchsh -s /usr/bin/fish（需要输入您的密码）Tip：可以使用 whereis xxx 命令，来查找 xxx 程序的安装位置，详见搜索设定命令的搜索路径使用 echo $PATH ，可以显示 $PATH 变量，输出如下：/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/bin/X11 /usr/games /usr/X11R6/bin它是一个环境变量，代表执行命令时，Shell的搜索路径。执行一个命令时，Shell会到 $PATH 变量定义的路径去搜索，并运行与命令同名的可执行文件。如果程序、脚本等可执行文件并不在上面的路径中，就必须使用绝对路径或者相对路径定位可执行文件。例如：/usr/local/mplayer -menu xxx.rmvb/etc/init.d/powernowd startcd /usr/local/ &amp;&amp; ./mplayer -menu xxx.rmvb可以修改 /etc/environment 文件来设定您的命令搜索路径，找到 PATH 起始的行PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin&quot;在双引号中添加您的自定义路径，并以 : 分隔。Ubuntu系统简介Ubuntu系统目录结构以下为Ubuntu目录的主要目录结构，您稍微了解它们都包含了哪些文件就可以了，不需要记忆。/ 根目录│├boot/ 启动文件。所有与系统启动有关的文件都保存在这里│ └grub/ Grub引导器相关的文件│├dev/ 设备文件├proc/ 内核与进程镜像│├mnt/ 临时挂载├media/ 挂载媒体设备│├root/ root用户的$HOME目录├home/│ ├user/ 普通用户的$HOME目录│ └.../│├bin/ 系统程序├sbin/ 管理员系统程序├lib/ 系统程序库文件├etc/ 系统程序和大部分应用程序的全局配置文件│ ├init.d/ SystemV风格的启动脚本│ ├rcX.d/ 启动脚本的链接，定义运行级别│ ├network/ 网络配置文件│ ├X11/ 图形界面配置文件├usr/│ ├bin/ 应用程序│ ├sbin/ 管理员应用程序│ ├lib/ 应用程序库文件│ ├share/ 应用程序资源文件│ ├src/ 应用程序源代码│ ├local/│ │ ├soft/ 用户程序│ │ └.../ 通常使用单独文件夹│ ├X11R6/ 图形界面系统│├var/ 动态数据│├temp/ 临时文件├lost+found/ 磁盘修复文件启动流程Linux系统主要通过以下步骤启动：***1.读取MBR的信息，启动Boot Manager***Windows使用NTLDR作为BootManager，如果您的系统中安装多个版本的Windows，您就需要在NTLDR中选择您要进入的系统。Linux通常使用功能强大，配置灵活的GRUB作为Boot Manager，我们将在启动管理章节中向您介绍它的使用方式。***2.加载系统内核，启动init进程***init进程是Linux的根进程，所有的系统进程都是它的子进程。***3.init进程读取 /etc/inittab文件中的信息***，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动，并指向一个系统中的程序。通常情况下， /etc/rcS.d/ 目录下的启动脚本首先被执行，然后是 /etc/rcN.d/ 目录。例如您设定的运行级别为3,那么它对应的启动目录为 /etc/rc3.d/ 。***4.根据 /etc/rcS.d/文件夹中对应的脚本启动Xwindow服务器 xorg***Xwindow为Linux下的图形用户界面系统。***5.启动登录管理器，等待用户登录***Ubuntu系统默认使用GDM作为登录管理器，您在登录管理器界面中输入用户名和密码后，便可以登录系统。（您可以在 /etc/rc3.d/ 文件夹中找到一个名为 S13gdm 的链接）更改运行级别在 /etc/inittab 文件中找到如下内容：\# The default runlevel.id:2:initdefault:这一行中的数字 2 ,为系统的运行级别，默认的运行级别涵义如下：***0关机       1单用户维护模式         2~5多用户模式         6重启***服务管理更改启动服务在运行级别对应的文件夹中，您可以看到许多文件名以 S## 和 K## 起始的启动脚本链接。例如：/etc/rcS.d/S35mountall.sh 挂载文件系统/etc/rcS.d/S40networking 启用网络支持/etc/rc2.d/S13gdm 启动登录管理器/etc/rc2.d/S20makedev 创建设备文件/etc/rc2.d/S23xinetd 启动超级进程init进程将以 start 为参数，按文件名顺序执行所有以 S## 起始的脚本。脚本名称中的数字越小，它将被越早执行。例如在/etc/rc2.d/ 文件夹中， S13gdm 文件名中的数字小于 S23xinetd , S13gdm 将比 S23xinetd 先执行。如果一个脚本链接，以 K## 起始，表示它将以 stop 参数被执行。如果相应服务没有启动，则不执行该脚本。例如：/etc/rc2.d/K20powernowd 针对某种硬件的电源管理支持如果您想禁止某一服务在启动时自动运行，您可以将相应运行级别中的脚本由 S##xxx 重命名为 K##xxx 。手动控制服务您也可以手动运行带有以下参数的启动脚本，来控制系统服务。***- start启动      - stop停止      - restart重启***例如：/etc/rc2.d/K20powernowd start有时您并不清楚当前运行级别，该运行级别下未必有相应脚本；而且此类脚本的前三位字符并不固定，不便于记忆。这时，可以直接使用/etc/init.d/ 文件夹中的启动脚本（ /etc/rcX.d/ 中的启动脚本链接到 /etc/init.d/文件夹下相应脚本），这也是推荐的方式。例如：/etc/init.d/powernowd startNote：以上命令的位置并没有包含在环境变量的搜索路径中，所以要输入完整路径。常用系统服务acpi-support 高级电源管理支持          acpid acpi守护程序.这两个用于电源管理，非常重要alsa   声音子系 统                    alsa-utilsanacron cron的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行。apmd  acpi的扩 展                  atd 类似于cron的任务调度系统。建议关闭binfmt-support  核心支持其他二进制的文件格式。建议开 启                   bluez-utiles 蓝牙设备支持bootlogd  启动日志。开启 它                  cron 任务调度系统，建议开启cupsys  打印机子系 统。               dbus 消息总线系统(message bus system)。非常重要dns-clean 使用拨号连接时，清除dns信息。evms 企业卷管理系统（Enterprise Volumn Management system）fetchmail   邮件用户代理守护进程，用于收取邮 件                   gdm gnome登录和桌面管理器。Gdomap               gpm  终端中的鼠标支持。            halt 别动它。hdparm 调整硬盘的脚本，配置文件为 /etc/hdparm.conf。             hibernate 系统休眠hotkey-setup 笔记本功能键支持。支持类型包括： HP, Acer, ASUS, Sony, Dell, 和IBMhotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它hplip HP打印机和图形子系统             ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它inetd  在文件 /etc/inetd.conf  中，注释掉所有你不需要的服务。如果该文件不包含任何服务，那关闭它是很安全 的。               klogd 重要。linux-restricted-modules-common 受限模块支持。 /lib/linux-restricted-modules/ 文件夹中的模块为受限模块。例如某些驱动程序，如果您没有使用受限模块，就不需要开启它。lvm   逻辑卷管理系统支 持。                  makedev  创建设备文件，非常重要。            mdamd 磁盘阵列module-init-tools 从/etc/modules加载扩展模块，建议开启。networking 网络支持。按 /etc/network/interfaces 文件预设激活网络，非常重要。ntpdate   时间同步服务，建议关 闭。             pcmcia  pcmcia设备支持。            powernowd 移动CPU节能支持ppp and ppp-dns  拨号连 接                    readahead 预加载库文件。           reboot 别动它resolvconf  自动配置 DNS             rmnologin  清除 nologin                  rsync rsync守护程序sendsigs  在重启和关机期间发送信号            single  激活单用户模 式                  ssh ssh守护程序。建议开启stop-bootlogd  在2，3，4，5运行级别中停止bootlogd服 务                    sudo 检查sudo状态。重要sysklogd  系统日 志               udev &amp; udev-mab 用户空间dev文件系统（userspace dev filesystem）。重要umountfs   卸载文件系 统                urandom  随机数生成 器                 usplash 开机画面支持vbesave 显卡BIOS配置工具。保存显卡的状态            xorg-common 设置X服务ICE socket。adjtimex 调整核心时钟的工具              dirmngr 证书列表管理工具,和gnupg一起工作。hwtools   irqs优化工 具                    libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序。lm-sensors  板载传感器支 持                   mdadm-raid 磁盘陈列管理器screen-cleanup 清除开机屏幕的脚本             xinetd 管理其他守护进程的一个inetd超级守护程序重要配置文件！无论任何情况下，修改配置文件之前，先备份它！建议使用这个命令： sudo cp xxx xxx_</code>date +%y%m%d_%H:%M<code>。当然这很麻烦，您可以新建一个名为 bak 的文件，内容如下：\#!/bin/bashsudo cp $1 $1_</code>date +%y%m%d_%H:%M<code>把它放在您能够记住的目录下，比如 /home ，执行命令 sh /home/bak xxx ，就可以将当前文件夹下的文件 xxx 另存为 xxx_yymmdd_HH:MM 的格式了全局配置文件系统初始化/etc/inittab   运行级别、控制台数 量                 /etc/timezone  时 区                /etc/inetd.conf 超级进程文件系统/etc/fstab  开机时挂载的文件系 统                   /etc/mtab 当前挂载的文件系统用户系统/etc/passwd  用户信 息                    /etc/shadow  用户密 码                    /etc/group 群组信息/etc/gshadow  群组密 码                  /etc/sudoers Sudoer列表（请使用“visudo”命令修改此文件，而不要直接编辑）Shell/etc/shell   可用Shell列 表               /etc/inputrc  ReadLine控件设 定               /etc/profile 用户首选项/etc/bash.bashrc bash配置文件系统环境/etc/environment  环境变量            /etc/updatedb.conf  文件检索数据库配置信 息                   /etc/issue 发行信息/etc/issue.net                  /etc/screenrc 屏幕设定网络/etc/iftab  网卡MAC地址绑 定               /etc/hosts  主机列 表              /etc/hostname 主机名/etc/resolv.conf  域名解析服务器地 址              /etc/network/interfaces 网卡配置文件用户配置文件/etc/ 目录下的文件，只有root用户才有权修改。应用软件的全局配置文件，通常普通用户也不能够修改，如果要通过配置软件，来适应特殊需求，您可以修改用户配置文件。用户配置文件通常为全局配置文件的同名隐藏文件，放在$HOME目录下，例如：/etc/inputrc /home/user/.inputrc/etc/vim/vimrc /home/user/.vim/vimrc也有少数例外，通常是系统程序软件安装DPKGLinux系统中，软件通常以源代码或者预编译包的形式提供。软件源代码需要编译为二进制的机器代码才能够使用，安装比较耗时，不过您可以自行调节编译选项，决定需要的功能或组件，或者针对硬件平台作一些优化。预编译的软件包，通常是由软件的发布者进行编译，您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性，预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。Ubuntu系统中，软件通常以 deb 格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其它软件包的依赖关系纪录、比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。deb软件包命令遵行如下约定：soft_ver-rev_arch.deb*soft软件包名称ver软件版本号revUbuntu修订版本号arch目标架构名称*例如： azureus_2.4.0.2-0ubuntu2_all.deb您需要使用 dpkg 命令来管理deb软件包：dpkg -i | --install xxx.deb 安装deb软件包dpkg -r | --remove xxx.deb 删除软件包dpkg -r -P | --purge xxx.deb 连同配置文件一起删除dpkg -I | -info xxx.deb 查看软件包信息dpkg -L xxx.deb 查看包内文件dpkg -l 查看系统中已安装软件包信息dpkg-reconfigure xxx 重新配置软件包有些时候，您使用 dpkg 安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包dpkg -i aaa.deb bbb.deb ccc.debAPT如果一个软件依赖关系过于复杂，使用 dpkg来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过您预设的方式来获得相关软件包，并自动安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。APT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为 源 。 源 可以是网络服务器，安装CD或者本地软件仓库。您需要修改 /etc/apt/sources.list 文件，使APT系统能够连接到 源。从以下页面中获得网络安装源的列表，并且根据您的网络环境，选择速度较快的源。http://wiki.ubuntu.org.cn/%E5%BF%AB%E9%80%9F%E......%97/DapperDrakeAPT系统主要包括 apt-get 和 apt-cache 等命令。通常是复合命令，包含若干个子命令。apt-get install xxx 安装xxx*-d仅下载-f强制安装*apt-get remove xxx 卸载xxxapt-get update 更新软件信息数据库apt-get upgrade 进行系统升级apt-cache search 搜索软件包说明：建议您经常使用 sudo apt-get update 命令来更新您的软件信息数据库APT系统修复由于各种意外，APT系统可能会出现问题，使用如下命令，尝试进行修复：apt-get -f install源码包对于绝大多数软件，我们建议您使用APT系统来安装它。在少数情况下，例如某软件没有以deb包的格式发布，或者需要定制适合自己的软件，您可以通过编译源代码的方式安装它。首先需要下载软件的源码包，并且将它解包为一些源代码文件。并了便于管理，建议将下载的源码包移动到 /usr/local/src/ 目录下，并在这里解包。sudo mv xxx.tar.gz /usr/local/src 移动源码包cd /usr/local/src 进入“/usr/local/src/”目录sudo tar -xzvf xxx.tar.gz 解包源码cd xxx_ver/ 进行解包后的源码目录源码目录中通常有一个 configure 脚本，用来配置即将开始的编译过程。您可以执行它sudo ./configure [--prefix=/usr/loca/xxx ......]它会自动检测软件的编译环境和依赖关系，并且生成 Makefile 文件。使用带参数的命令 ./configure --help ，或者阅读 INSTALL 文件，查看该脚本允许的参数。例如使用--prefix=/usr/local/xxx 参数，将软件的安装目录设定为 /usr/local/xxx/。（如果一定要将软件安装在单独目录下，建议您安装在这里）现在执行 make 命令，系统会根据 Makefile 文件中的设定，通过 make 工具调用编译器和所需资源文件，将源代码编译成目标文件。sudo make执行 make install 命令， make 工具会自动连接目标文件和库文件，将最终生成的文件拷贝到 Makefile 文件设定的路径中，并且完成更改文件的属性，删除残留文件等活动。sudo make install现在，编译安装已经完成，为了更方便的使用它，需要给程序的可执行文件作一个符号链接。sudo ln -sf /usr/local/xxx/可执行文件 /usr/local/bin/可执行文件Tip:为了顺利的进行编译，至少需要安装 build-essential 软件包。sudo apt-get install build-essentialXwindow简介Xwindow是工作站图形系统的工业标准，它有多种不同的实现，Ubuntu系统中使用的为Xorg。（比较前卫的图形界面系统XGL，实际代替X服务器的作用，另外还有与之配套的窗口管理器）历史当然，Xwindow有悠久的历史和传统，不过那不在我们讨论的范围。您要注意的有两点：\* Xwindow 和 Xbox 中的“X”本意是不同的， X 只是 W 后的一个字母，差不多应该这样理解，Xwindow 是 Window 的接班人 （注意，Window不是Windows）\* 同样，也不要把 Xwindow 说成是 Xwindows，那是一种亵渎！一切伟大的创造，都应得到应有的理解和尊重。架构及原理Xwindow使用服务器－客户端架构。无论本地图形界面，还是远程图形界面，都以同样的流程工作。这样便不需要分别进行设计和维护，极大的提高了网络透明性。本地X客户端 ┐ ┌ 键盘远程X客户端 ┼ X协议 ─ X服务器 ─ 硬件规范 ┼ 鼠标远程X客户端 ┘ └ 显示器XserverXwindow系统服务器端，通过驱动程序（硬件规范）来管理硬件资源。例如：当我们移动鼠标时，通过驱动程序，向 Xserver 发送信息：“向右移动200点，向上移动100点”（向右上移动）；“按下左键”……Xserver作出如下响应：1、上一次鼠标停止的坐标为600,5002、向右200，向上100。现在鼠标位于坐标800,6003、坐标800,600处，为窗口Firefox的“关闭”按钮4、根据预设动作，将 “点击Firefox窗口的关闭按钮” 翻译为 “关闭窗口Firefox”5、向X客户端Firefox发送一个“退出”消息6、Xserver通过显示子系统（显卡、显示器），全程显示鼠标的位置和移动\* 事实上，向程序发送“退出”信号，通常窗口管理器完成……为了描述方便，这里暂不区分。稍后，我们将向您介绍 窗口管理器 的其它一些细节。大多数的鼠标不需要专门的驱动程序，因为它们符合某一硬件规范，例如：有四个移动方向和三个键XclientXwindow系统客户端，通过X协议，实现与Xserver 的交互。例如：1、Xclient （假设Firefox） 接收Xserver的消息： 输入焦点在地址栏的范围内，“ubuntu.org.cn”，回车2、Firefox根据预设动作，将这些消息识别为 “打开链接 ubuntu.org.cn”3、Firefox向域名服务器请求 链接 “ubuntu.org.cn”。域名服务器将这个请求转换为 “http://ubuntu.org.cn/” 和 IP地址211.148.131.7，发送回 Firefox4、Firefox将 “http://ubuntu.org.cn/”显示在地址栏（向Xserver发送请求，在地址栏位置显示这个地址）5、Firefox向地址 211.148.131.7 请示显示页面。6、Firefox将服务器发送回的页面显示在主窗口中XprotocolXwindow系统协议，Xserver和Xclient之间进行通信的规则窗口管理器Window Manager，一种特殊的Xclient。使用窗口管理器时，Xserver并不直接与其它Xclient通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如Alt+F4关闭窗口、拖动标题栏……消息“打开链接 ubuntu.org.cn”，具体内容如下：输入焦点在地址栏的范围内，“ubuntu.org.cn”，回车Xserver并不能直接判断焦点，而是这样：1、Xserver向WM发送位置和点击的信息，WM根据当前的“焦点策略”确定激活（最上层）的窗口为Firefox2、Xserver将Firefox显示在最上层，高亮显示它的标题栏3、在窗口Firefox内点击地址栏，或者 Ctrl+L，Xserver将位置信息发送给WM，WM再发送给Firefox4、Firefox判断当前焦点后，显示一个闪动的文字输入光标5、Firefox将输入光标通过WM发送给Xserver，Xserver在屏幕相应位置进行显示那么，“窗口管理器”到底能作些什么呢？其实它所作的一切都是管理窗口。例如：1.最上层的窗口会把其它窗口挡住2.它通常是一个“已激活窗口”，根据不同的“焦点策略”，窗口管理器确定被激活的窗口。激活窗口标题栏高亮显示，接收大部分的键盘消息和窗口内的鼠标点击消息。3.为了美观和容易分辨，大多数窗口都要有标题栏和边框。为了方便，标题栏上还要有一些按钮，比如：最小化，最大化，关闭（这些按钮是窗口管理器请求的小窗口）4.一个窗口可以在另一个窗口旁边显示，而不一定完全被遮挡。为了实现这一点，就要控制窗口显示的位置5.为了控制窗口的显示位置，需要将整个屏幕用座标描述，最好的办法是绘制一个填充整个屏幕的窗口，也就是根窗口。6.因为根窗口是最大的，所以它可以严严实实的遮挡任何窗口，为了避免这一点，根窗口永远在最底层。这很形象的说明了为什么它叫作“根窗口” ……root7.根窗口不一定只有一个，大多数的窗口管理器可以使用 “工作区” ，来切换显示多个根窗口8.根窗口固定位置上通常放置一些其它Xclient的窗口，例如底部面板，顶部面板，侧面板，程序启动图标9.面板上又可以放一些其它的Xclient窗口，如任务条，启动栏，菜单……任务条可以以图标显示正在运行的任务，还可以作其它的杂活，像自动挂载USB设备……启动流程我们知道 init 是linux的根进程，是所有进程的父进程。同样， xinit是所有Xwindow进程的根进程Startxstartx 命令可以在命令行下启动图形界面。执行startx 命令时，实际执行这一命令：xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc根据脚本 /etc/X11/xinit/xserverrc 启动Xserver，同时根据脚本 /etc/X11/xinit/xinitrc 启动指定Xclient进程，例如窗口管理器脚本 /etc/X11/xinit/xserverrc 以预设的参数运行程序 /usr/bin/X11/X/etc/X11/xinit/xinitrc 脚本则指向 /etc/X11/Xsession ，依次启动 /etc/X11/Xsession.d 目录中的脚本\* 您可以在用户配置文件 ~/.Xsession 中定义使用的WM，它的优先级高于全局配置文件(对于GDM会话不起作用)\* startx启动时，并不会再进行身份认证。因为它启动的是 /etc/X11/Xsession.d/gnome-session ，而不是 GDM会话GDM会话Ubuntu系统启动时自动进入图形界面，不需要运行 startx 命令在某些启动级别中，包含了gdm的启动脚本，例如 ： /etc/rc2.d/S13gdm\1. 指向 /etc/gdm/gdm-cdd.conf 文件，加载预设视觉主题，启动 /usr/lib/gdm/gdmgreeter（登录屏幕）\2. 用户身份认证完成后，启动 /etc/X11/default-display-manager 这个文件中设定的默认窗口管理器 /usr/sbin/gdmgdm在启动时，会要求用户名和密码，也就是我们看到的登录屏幕（gdmgreeter）\* /usr/share/xsessions 目录下为所有可用登录会话的脚本配置文件X服务器X服务器的主要配置文件为 /etc/X11/xorg.conf布局Section &quot;ServerLayout&quot;Identifier &quot;Default Layout&quot;Screen &quot;Default Screen&quot; 0 0InputDevice &quot;Generic Keyboard&quot;InputDevice &quot;Configured Mouse&quot;EndSection\* 定义了 布局标识 、 屏幕标识 、 键盘标识 、 鼠标标识模块Section &quot;Module&quot;Load &quot;i2c&quot;Load &quot;bitmap&quot;Load &quot;ddc&quot;Load &quot;dri&quot;Load &quot;extmod&quot;Load &quot;freetype&quot;Load &quot;glx&quot;Load &quot;int10&quot;Load &quot;type1&quot;Load &quot;vbe&quot;EndSectionX核心字体路径Section &quot;Files&quot;FontPath &quot;/usr/share/X11/fonts/75dpi&quot;FontPath &quot;/usr/share/X11/fonts/100dpi&quot;FontPath &quot;/usr/share/X11/fonts/misc&quot;FontPath &quot;/usr/share/X11/fonts/cyrillic&quot;FontPath &quot;/usr/share/X11/fonts/100dpi/:unscaled&quot;FontPath &quot;/usr/share/X11/fonts/75dpi/:unscaled&quot;FontPath &quot;/usr/share/X11/fonts/Type1&quot;FontPath &quot;/usr/share/fonts/Chinese/wqy-bitmapfont&quot;EndSection屏幕Section &quot;Screen&quot;Identifier &quot;Default Screen&quot;Device &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;Monitor &quot;DELL E176FP&quot;DefaultDepth 24SubSection &quot;Display&quot;Depth 1Modes &quot;1280x1024&quot; &quot;1152x864&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;720x400&quot; &quot;640x480&quot;………………EndSubSectionEndSection\* DefaultDepth 24 默认色深\* SubSection 可用色深及分辨率显卡Section &quot;Device&quot;Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;Driver &quot;fglrx&quot;Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;VideoRam 131072EndSection\* Identifier 显卡标识\* Driver 显卡驱动（如不同正常启用图形界面，首先尝试&quot;vesa&quot;）\* Option 显卡参数\* VideoRam 显存大小显示器Section &quot;Device&quot;Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;Driver &quot;fglrx&quot;Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;VideoRam 131072EndSection配置文件内部结构/├/ &quot;ServerLayout&quot; 布局│├ &quot;InputDevice&quot; keyboard 键盘│├ &quot;InputDevice&quot; mouse 鼠标│││└/ &quot;Screen&quot; 显示子系统│ ├ &quot;Monitor&quot; 显示器│ ├ &quot;Device&quot; videocard 显卡││├ &quot;Files&quot; 字体└ &quot;Module&quot; 模块X客户端在 /etc/X11/Xsession 文件中可以发现下列内容OPTIONFILE=/etc/X11/Xsession.optionsSYSRESOURCES=/etc/X11/XresourcesUSRRESOURCES=$HOME/.XresourcesSYSSESSIONDIR=/etc/X11/Xsession.dUSERXSESSION=$HOME/.xsessionALTUSERXSESSION=$HOME/.XsessionERRFILE=$HOME/.xsession-errors\* OPTIONFILE=/etc/X11/Xsession.options 设定X进程的启动参数。例如允许用户进程allow-user-xsession\* Xresources X资源文件。许多程序保留了X接口，允许X服务器管理一些视觉选项，例如窗口内的字体，配色等\* xsession X进程。可以设置一些启动时自动运行的程序，也可以用来设定自己的窗口管理器（窗口管理器和桌面环境或者登录管理器是无关的）字体freetype渲染引擎作为Xorg服务器的一个模块，freetype的功能包括读取Truetype字体信息，如大小、分辨率、编码等，并以之为依据渲染字体 -freetype2.x相对于freetype1.x 增加了抗锯齿等功能 - ( /etc/X11/xorg/conf 的 Module字段中，可以选择字体渲染模块，建议使用默认的 freetype )freetype只负责渲染字体。而查找字体，则可以由X服务器、X客户端或者字体服务器来完成。找到字体后，使用freetype引擎就地渲染X核心字体X服务器根据X客户端的请求（字符编码），查找字体并进行渲染，然后显示，我们称之为Xft字体X客户端自行查找字体并进行渲染，X服务器只负责显示由于Xft字体的渲染在客户端完成，所以它可以动态的加载，而不需要随同X服务器一同启动字体服务器另外还有一种字体服务器模式，例如 XFT字体：当客户端请求字体时，X服务器将请求转发到字体服务器，由字体服务器查找字体，并使用freetype引擎渲染，将结果传回X服务器，X服务器进行显示……X核心字体/etc/X11/xorg.conf 中可以配置X核心字体的搜索路径Section &quot;Files&quot;FontPath &quot;/usr/X11R6/lib/X11/fonts/misc/&quot;FontPath &quot;/usr/X11R6/lib/X11/fonts/Type1/&quot;FontPath &quot;/usr/X11R6/lib/X11/fonts/Speedo/&quot;FontPath &quot;/usr/X11R6/lib/X11/fonts/100dpi/&quot;FontPath &quot;/usr/X11R6/lib/X11/fonts/75dpi/&quot;EndSection*当X客户端向X服务器请求显示文字的时候，X服务器会按上面列表的先后顺序查找字体例如显示中文时，如果第一个路径中的字体不包含中文，则查找下面的路径，直到发现中文字体*请将您偏好的字体放在靠前的位置要使安装的字体能够作为X核心字体使用，将字体的安装路径添加到上面的列表中，使用 mkfontscale 、 mkfontdir扫瞄文件夹中的字体，并生成索引，就可以了（建议使用 ttmkfdir 生成 fonts.scale ，将其复制为 fonts.dir ）字体的选择及显示风格，可以修改GTK1的配置文件，或者在Xresources文件中对程序单独进行定义事实上，在我们的日常应用中，X核心字体环境并不常见，使用GTK1图形库的程序、某些类型的终端……\* Emacs也是这样一个老派的程序……不过Emacs23中刚刚加入了xft字体的支持XFT字体Xft字体相关选项在 /etc/fonts/fonts.conf 文件中配置可以使用 fc-cache 命令，递归扫瞄以下目录中的字体（包括子文件夹中的字体），建立字体缓存/usr/share/X11/fonts/usr/share/fonts/usr/local/share/fonts~/.fonts\* /etc/fonts/fonts.conf 文件的  字段多数支持GTK2或者Qt图形库的X客户端能够使用Xft字体渲染技术\* GTK2为Gnome使用的图形库，Qt为KDE使用的图形库。相对来说，GTK2图形库在程序的GUI设计中更加通用安装字体，只要将字体拷贝到以上任意目录， fc-cache -fv 刷新字体缓存即可 （参数: -f 强制刷新; -v 显示过程）使用命令 fc-list 列出所有可用字体字体的选择及显示风格，可以修改GTK2或者Qt的配置文件，建议使用图形界面配置\* 一般情况下，桌面环境中附带了相关程序，例如 gnome-font-properties系统管理一些细节Linux是大小写敏感的系统，所有的命令、路径、参数、变量……都区分大小写使用 TAB 键补全命令，无论任何时候，多按几次TAB总会有所帮助Shell的功能键能够协助您更高效的编辑命令，请熟悉其键绑定，尽量使用它命令由 命令名 、 分隔符 、 参数 、 操作对象 构成命令名标识命令的功能，例如cp(copy)、mv(move)、rm(remove)……有些命令包含一些子命令，您可以认为它的命令名由两个单词构成，例如“apt”软件包管理系统：apt-get install 安装一个软件apt-get remove 删除一个软件分隔符通常为空格，多个连续的空格视为一个空格，下面两个命令相同：cp a bcp a b有一些特殊符号也属于分隔符，例如管道 | 、重定向 &gt; 、 &gt;&gt; 、 &lt; 、后台运行 &amp; 、序列执行 &amp;&amp; 、 ; 。使用这些符号时，您不需要再使用空格作为分隔符，例如：ls -al|less写为以下形式，是为了让您更容易的阅读它：ls -al | less参数精细调节命令的行为，以 - 引导，通常为参数名的首字母。许多软件都可以使用 -h 参数来阅读使用说明，例如：apt-get -h也可以使用参数的全名，一般以 -- 引导，例如：apt-get --help多数命令中，使用 - 引导多个字符，将会被视为多个参数，例如：apt-get -help系统会解读为以下命令apt-get -h -e -l -p少数命令的参数，不需要以 - 引导，或者使用 - 引导参数全名，例如：ps aux/etc/init.d/gdm startmplayer -loop xxx需要对多个对象进行操作时，可以使用空格分隔符将它们隔开：touch 1 2 3 4 5 6使用空格分隔的多个对象，视为一个整体，作为命令的一个操作对象：mv 1 2 3 4 5 6 /home/这个命令把“1 2 3 4 5 6”作为一个操作对象，移动到另一个操作对象，“/home/”目录递归 表示在子层次中重复相同操作。例如递归复制某目录，不但复制当前目录及其下的所有文件；而且对当前目录的子目录，也进行递归复制的操作。格式约定使用 [] 表示可选项，实际输入为方括号中的内容，例如ls [-al]ls是必须的，参数不需要以方括号括起来。使用 &lt;&gt; 表示必需项，实际输入为尖括号中的内容使用 | 表示 或 ，以 | 分隔的项目不能同时使用，例如tar [-z|j c|x vf] &lt;归档文件&gt; [源文件]参数通常紧跟命令名，除非必要，在命令格式中，我们通常省略它们系统信息uptime联机信息-时间，显示如下11:27pm up 9 days, 7:12, 3 user, load average: 0.07, 0.12, 0.14当前系统时间 系统运行时间 当前在线用户数 系统负荷 1分钟前 5分钟前 15分钟前w联机信息-已登录用户，显示如下01:04:10 up 1:34, 2 users, load average: 0.25, 0.16, 0.11uptime 信息USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATuser tty1 192.168.0.1 23:30 1:33 0.14s 0.12s -bash用户名 登录方式 来源地址 登录时间 发呆时间 资源占用 当前任务Tip：w [用户名称] : 显示某一用户相关信息who联机信息，常用参数***-r运行级别***whoami显示当前用户名last最近用户登录信息-&lt;数字&gt; 使用数字作为参数，控制显示条目。例如last -10 显示10条纪录uname系统信息*-s内核名称（默认参数）-a全部-p CPU信息-n主机名**-r内核发行信息（版本号）-v内核版本信息*date显示、设定系统时间-u 显示格林尼洛时间（UTC）MMDDhhmm[[CC]YY][.ss] 设定时间，需要管理员权限。例如： date 12292359MM 月份 DD 天数 hh 小时 mm 分钟 CC 年份前两位 YY 年份后两位 ss 秒钟秒钟、年份为可选，例如： date 122923592006.59+[%X]设定显示格式，以下为date默认输出格式：date +%Y年%m月%d日%A%H:%M:%S%Z格 式控制            %n   换 行              %t 制表符小 时                     %H(00~23) %I(01~12) %k(0~23) %l(1~12) %p(AM|PM)分、 秒                  %M分钟 (00~59)                    %S秒 (00..61)               %T(hh:mm:ss) %r(hh:mm:ss [AM|PM])%s 从1970年1月1日00:00:00  UTC到目前为止的秒 数                %X(%H:%M:%S)                  %Z时区星 期                     %a(Sun~Sat) %A(Sunday~Saturday) %w : 一周中的第几天 (0..6)年 份                     %Y(0000~9999) %y(00~99)月 份                     %m(01~12) %b %h(Jan~Dec) %B(January~December)日 期                     %d(01~31) %j(001~366)%x(本地格式mm/dd/yy) %D(mm/dd/yy) %c一年中的第几周%U(00~53)以Sunday为一周的第一天 %W(00~53)以Monday为一周的第一天cal显示日历文件管理一些细节/ 目录为文件系统根目录，所有目录都是它的子目录绝对路径以 / 起始，相对路径以当前所在目录起始目录是一种特殊类型的文件，如果没有特别指明， 文件 包括文件和目录.. 表示上一级目录， . 表示当前目录，它们是两个特殊目录链接为当前文件建立在其它路径中的访问方法。例如将系统中其它位置的可执行文件，链接到 /usr/local/bin 目录下，使用命令调用。ls [路径]显示当前目录文件列表--color 不同属性以不同颜色显示（默认参数）*-a全部显示-i显示inode值-l详细信息**-F显示文件类型后缀目录/链接@可执行文件\*端口文件=管道文件| &gt;**-A显示隐藏文件-R递归显示子目录文件列表-S按文件大小排序**-t按修改时间排序-u按访问时间排序-d只显示目录，不递归显示目录下的文件*cd [目录路径] | [特殊路径]切换目录目录路径可以使用绝对路径或者相对路径特殊路径：*~ $HOME目录（默认值）-上一次目录..上一级目录.当前目录*说明：您可以通过修改 /etc/environment 文件，来定义 $CDPATH 变量，设定“cd”命令的搜索路径。pwd显示当前路径file &lt;文件名&gt;显示文件类型***-i显示mime类型***du [路径]计算文件或目录空间占用*-h人性化显示。自动以G、M、K为单位显示占用空间大小-l重复计算硬链接文件大小**-L计算符号链接文件大小-a显示当前目录子目录中的文件-c显示文件数*less &lt;文件名&gt;浏览文件，使用VI和Emacs两种风格的键绑定。以下为VI风格键绑定*Ctrl+f(orward)向下翻一页Ctrl+d(own)向下翻半页**Ctrl+b(ackward)向上翻一页Ctrl+u(p)向上翻半页/查找q(uit)退出*touch &lt;目标文件&gt;触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件mkdir &lt;文件夹&gt;创建文件夹*-p &lt;多级目录&gt;按路径创建多级目录-m &lt;数字权限值&gt;设定权限*cp &lt;源文件&gt; &lt;目标目录|文件&gt;将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔cp &lt;源目录&gt; &lt;目标目录&gt;将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 参数*-a相当于-dpr参数-d保留链接-f强制复制，覆盖目标文件-i覆盖时询问用户**-p保留修改时间和访问权限-r -R递归复制（目录=&gt;目录）-l创建链接**-v显示过程*rm &lt;目标目录|文件&gt;删除*-r -R递归删除-f强制删除（无需确认，直接删除。慎用！）-i交互式删除（询问用户）*rmdir &lt;目标目录&gt;删除目录时，建议您使用“rm -r”命令mv &lt;源文件&gt; &lt;目标目录|文件&gt;相当于cp后删除源文件，也可以作为“重命名”使用。mv &lt;源目录&gt; &lt;目标目录&gt;*-r -R递归*ln &lt;源文件&gt; &lt;链接&gt;链接*-s符号链接-f强制链接，覆盖目标文件-i覆盖前询问用户*文件操作nano一个简单轻便的文本编辑器，使用Emacs风格的键绑定。split &lt;源文件&gt; [目标文件名前缀]将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x*-&lt;行数&gt;按行数分割文件-l &lt;行数&gt;同上**-b &lt;字节&gt;按大小分割文件。可以使用b、k、m作单位，不指定单位的情况下，默认单位为b**-C &lt;字节&gt;按大小分割文件，并尽量保持每行的完整*示例：split -C 100k file.split xcat &lt;文件名&gt;输出文件内容。用空格分隔多个文件名，可以将多个文件内容连接到一起输出。使用重定向合并为一个文件*-n在输出中添加行号-b在输出中添加行号，空行不编号**-s将两行或以上的空行，合并为一个空行*示例：cat xaa xab xac &gt; file.splitsort [-o &lt;输出文件&gt;] [-t &lt;分隔字符&gt;] [+&lt;起始字段&gt; - &lt;结束字段&gt;] [文件]对文本内容排序*-m合并文件-c检查文件是否已按规则排序-b忽略行首空格字符**-u忽略内容重复行-f忽略大小写-l忽略非打印字符-M作为月份比较**-d按字典顺序排序，按照字母、数字、空格、制表符排序-r逆序输出*more查看文件内容，我们建议您使用 lessdiff &lt;文件名&gt;比较文件cksum [文件名]计算文件的CRC值。不指定文件名则从标准输入设备读入数据，例如：echo xxx | cksummd5sum [文件名] 计算文件的md5值。同上权限管理一些细节一个文件主要包含下列属性， ls -l\- rwx rwx rwx user group date filename111 101 101其中，第一组为归属用户的权限，第二组为归属群组的权限，第三组为其它用户群组的权限。user为文件的归属用户，group为文件的归属群组，date为日期信息，filename为文件名。对于文件夹，必须拥有它的可执行权限，才能够使用 cd 命令进入该文件夹；拥有可读权限，才能够使用 ls 命令查看该文件夹的文件列表。root用户拥有最高权限。可以使用3位的二进制数字来描述一组权限，某一权限对应的数字为1,则表示具有该种权限，为0,则不具有该种权限。使用二进制数字来描述一组权限，虽然非常直观，但是3组权限需要用9位数来表示，使用不够方便。因此我们将三组权限使用3位8进制数字来表示。它们的对应关系为：r 100 4w 010 2x 001 1将这三位8进制数字相加的结果，就可以表示该组权限的具体内容，例如：7=4+2+1=rwx5=4+1=rx755=4+2+1 4+1 4+1=rwx r-x r-x还可以使用 a 、 u 、 g 、 o 表示归属关系，使用 = 、 + 、 - 表示权限变化，使用 r 、 w 、 x 表示权限内容，a 所有用户 u 归属用户 g 归属群组 o 其它用户= 具有权限 + 增加权限 - 去除权限r 可读权限 w 可写权限 x 可执行权限例如：a+x 给所有用户增加可执行权限go-wx 将归属群组和其它用户的可写、可执行权限去掉u=rwx 归属用户具有可读、可写、可执行权限chmod &lt;权限表达式&gt; &lt;文件|目录&gt;更改文件的权限。权限的表达式可以使用三位8进制数字表示，或者使用 augo +-= rxw-s 来表示-R 递归-v 显示过程-c 类似“-v”，仅显示更改部分--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限示例：chmod -R a+x pathchmod -Rv 755 pathchown &lt;归属用户&gt;[:归属群组] &lt;文件|目录&gt;更改文件的归属用户。可以使用用户名或者UID*-R递归-v显示过程-c类似-v，仅显示更改部分*--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限示例：chown  user:admin  path                    chown -R user.admin  path               chown user pathchgrp &lt;归属群组&gt; &lt;文件|目录&gt;更改文件的归属群组。可以使用群组名或者GID参数同上SUID、SGID、Sticky bit某些情况下，需要以可执行文件归属用户的身份执行该文件，可以为该文件设置SUID。同样，设置SGID能够以该文件归属群组的身份执行它。例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由root用户直接修改。-rw------- root root /etc/shadow这个时候，可以为程序 /usr/bin/passwd设置SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户root的身份修改 /etc/shadow文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。ls -l /usr/bin/passwd-r-s--x--x root root /usr/bin/passwd我们发现，归属用户的可执行权限位使用 s ，表示SUID。同样，归属群组的可执行权限位使用 s ，表示SGID。任何用户或群组都拥有其它用户 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t，也就是粘着位Sticky bit。ls -ld /tmpdrwxrwxrwt root root /tmp粘着位表示任何用户都可能具有写权限，但只有该归属用户或root用户才能够删除SUID、SGID、Sticky bit也可以像权限一样，使用一个八进制数表示，如下：4 SUID2 SGID1 Sticky bit通过在“chmod”命令中使用4个八进制数的表达式，如 4755 ，用第一位表示SUID、SGID、或Sticky bit，便能够为文件设置这些特殊权限。示例：chmod -R 4755 pathlsattr [路径]查看文件的特殊属性*-a全部显示-d只显示目录-R递归*特殊属性包括：*a：仅供附加用途b：不更新最后存取时间c：压缩后存放d：排除在倾倒操作之外**i：不得任意更动文件或目录s：保密性删除文件或目录S：即时更新文件或目录**u：预防以外删除*chattr +|-|=&lt;属性&gt; &lt;路径&gt;更改文件特殊属性*-R递归-V显示过程*压缩解压tar -c|x|u|r|t[z|j][v] -f &lt;归档文件&gt; [未打包文件]将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）*-c创建-x解包-u更新-r添加-t查看**-d比较压缩包内文件和文件-A将tar文件添加到归档文件中-z使用gz压缩格式**-j使用bz2压缩格式-v显示过程-f &lt;文件名&gt;归档文件的文件名**-C &lt;解压路径&gt;将压缩包中的文件解压到指定目录*[未打包文件] 创建、更新时必须填写示例：tar -zcvf xxx.tar.gz xxx/ xxx1 xxx2 xxx3 多个待打包文件以空格分隔tar -zcvf xxx.tar.gz /home/user/xxx/ 使用绝对路径打包，解包也使用绝对路径tar -zxvf xxx.tar.gz 按相对路径解包到当前目录下，或按绝对路径解包tar -zcvf xxx.tar.gz xxx | split -b 1m 打包后，使用split分割为1m大小的多个文件其它参数*-P使用绝对路径压缩时，保留根目录“/”             -W校验-p还原文件权限**-w询问用户--totals统计-T &lt;表达式&gt;处理符合条件的文件**-X &lt;表达式&gt;排除符合条件的文件*zip [参数] &lt;压缩包&gt; &lt;源文件&gt;使用zip格式打包文件*-r递归，将指定目录下的所有文件和子目录一并处理-S包含系统和隐藏文件**-y直接保存符号连接，而非该连接所指向的文件-X不保存额外的文件属性**-m将文件压缩并加入压缩文件后，删除源文件*-&lt;压缩级别&gt; 1~9，数字越大，压缩率越高*-F尝试修复已损坏的压缩文件-T检查备份文件内的每个文件是否正确无误**-q不显示指令执行过程-g将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件**-u更新压缩包内文件**-f更新压缩包内文件。如果符合条件的文件没有包含在压缩包中，则压缩后添加**-$保存第一个被压缩文件所在磁盘的卷标-j只保存文件名称及其内容**-D压缩文件内不建立目录名称-i &lt;表达式&gt;压缩目录时，只压缩符合条件的文件**-x &lt;表达式&gt;排除符合条件的文件-n &lt;文件名后缀&gt;排除指定文件名后缀的文件**-b &lt;缓存路径&gt;指定临时文件目录-d &lt;表达式&gt;从压缩文件内删除指定的文件**-t &lt;日期时间&gt;把压缩文件的日期设成指定的日期**-o以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同**-A调整可执行的自动解压缩文件-c替每个被压缩的文件加上注释**-z替压缩文件加上注释-k使用MS-DOS兼容格式的文件名称。**-l压缩文件时，把LF字符置换成LF+CR字符。-ll压缩文件时，把LF+CR字符置换成LF字符。*unzip [参数] &lt;压缩文件&gt; [压缩包中将被释放的文件]解压zip压缩包文件*-P &lt;密码&gt; zip压缩包的密码-d &lt;路径&gt;指定解压路径-n解压缩时不覆盖原有文件**-f覆盖原有文件-o不经询问，直接覆盖原有文件**-u覆盖原有文件，并将压缩文件中的其他文件解压缩到目录中**-l显示压缩文件内所包含的文件-t检查压缩文件是否正确-z显示压缩包注释**-Z unzip -Z等于执行zipinfo指令-j不处理压缩文件中原有的目录路径**-C压缩文件中的文件名称区分大小写-L将压缩文件中的全部文件名改为小写**-s将文件名中的空格转换下划线-X解压缩时保留文件原来的UID/GID**-q执行时不显示任何信息-v执行是时显示详细的信息**-c将解压缩的结果显示到屏幕上，并对字符做适当的转换**-p与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换**-a对文本文件进行必要的字符转换-b不要对文本文件进行字符转换**-x &lt;表达式&gt;处理里排除压缩包中的指定文件-M将输出结果送到more程序处理*7z|7za &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件]子命令*a添加d删除e解压x带路径解压l列表查看t测试u更新*参数*-m&lt;压缩方式&gt;            -m0=&lt;压缩算法&gt;默认使用lzma                  -mx=&lt;1~9&gt;压缩级别**-mfb=64 number of fast bytes for LZMA = 64           -md=&lt;字典大小&gt;设置字典大小，例如-md=32m**-ms=是否固实压缩-o&lt;输出目录&gt;设置输出目录-p[密码]使用密码**-r[数字]递归，使用数字定义递归子目录的深度-sfx[&lt;模块名称&gt;]使用自解压模块**-si从标准输入设备读入数据-so将数据写入标准输出设备-y所有询问均回答Yes**-w&lt;工作目录&gt;*rar &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件|文件列表|路径]子命令*x带路径解压e解压到当前目录a将文件添加到压缩包内d从压缩包中删除文件**u更新压缩包内文件f更新压缩包内文件，并添加压缩包内不存在的文件m添加并删除源文件**r修复l列表查看压缩包内文件信息lt更详细信息lb简短信息c添加压缩包注释*cf &lt;文件名&gt; 将文件内容添加为注释cw &lt;文件名&gt; 将注释保存为文件t   测试压缩 包               rr  添加恢复纪 录                   rv 恢复到文件参数-p&lt;密码&gt; 设置密码-m&lt;0~5&gt; 设置压缩级别，数字越大，压缩级别越高搜索whereis &lt;程序名称&gt;查找软件的安装路径*-b只查找二进制文件-m只查找帮助文件-s只查找源代码-u排除指定类型文件**-f只显示文件名-B &lt;目录&gt;在指定目录下查找二进制文件**-M &lt;目录&gt;在指定目录下查找帮助文件-S &lt;目录&gt;在指定目录下查找源代码*locate &lt;文件名称&gt;在文件索引数据库中搜索文件-d &lt;数据库路径&gt; 搜索指定数据库updatedb 更新文件索引数据库find [路径] &lt;表达式&gt;查找文件-name &lt;表达式&gt; 根据文件名查找文件-iname &lt;表达式&gt; 根据文件名查找文件，忽略大小写-path &lt;表达式&gt; 根据路径查找文件-ipath &lt;表达式&gt; 根据路径查找文件，忽略大小写-amin &lt;分钟&gt; 过去N分钟内访问过的文件-atime &lt;天数&gt; 过去N天内访问过的文件-cmin &lt;分钟&gt; 过去N分钟内修改过的文件-ctime &lt;天数&gt; 过去N天内修改过的文件-anewer &lt;参照文件&gt; 比参照文件更晚被读取过的文件-cnewer &lt;参照文件&gt; 比参照文件更晚被修改过的文件-size &lt;大小&gt; 根据文件大小查找文件，单位b c w k M G-type &lt;文件类型&gt; 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件-user &lt;用户名&gt; 按归属用户查找文件-uid  按UID查找文件-group &lt;群组名&gt; 按归属群组查找文件-gid  按GID查找文件-empty 查找空文件grep &lt;字符串&gt;|&quot;&lt;正则表达式&gt;&quot; [文件名]其它echo &lt;字符串&gt;回显。较复杂的字符串，可以使用 &quot; 括起来。*-n输出内容不换行-E不解析脱字符-e解析脱字符*控制字符*\反斜线a警告b退格n换行r回车t水平制表符*clear消除屏幕alias &lt;输入内容&gt; &lt;实际内容&gt;别名，为命令指定一个别名，以简化输入。例如：alias ls=&#39;ls --color=auto&#39;alias ls=&quot;l -CF&quot;可以将您的定义保存在 ~/.bashrc 文件中。export &lt;变量名称&gt;将变量导出为环境变量，常写变量赋值一同使用，例如：export PATH=&quot;$PATH:xxx&quot;其中 $PATH 表示变量 PATH 原值shutdown关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)*-h关闭电源-r重启-n强行关机，不向init进程发送信号**-k模拟关机，向登录者发送关机警告-t &lt;秒&gt; N秒后关机time &lt;时间&gt;定时关机**-c [说明信息]取消关机-f重启时忽略检测文件系统-F重启时强制检测文件系统*halt关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。*-n不同步文件系统-w模拟关机，写/var/log/wtmp纪录-f不调用shutdown ,强行关机**-p默认选项，关机时调用poweroff             -i关机前断开网络*reboot重新启动计算机。参数与 halt 相似chroot &lt;路径&gt;Change Root 更改根目录，重新定义会话的运行环境。用户管理一些细节root 用户为根用户，也就是 系统管理员 拥有全部权限一个用户只能拥有一个 GID ，但是还可以归属于其它附加群组用户管理的重要配置文件：/etc/passwd 用户名 密码位 UID 归属GID 姓名 $HOME目录 登录Shell/etc/shadow 用户名 已加密密码 密码改动信息 密码策略/etc/group 群组名 密码位 GID 组内用户/etc/gshadow 群组密码相关文件，不重要/etc/sudoers 用户名 权限定义 权限可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件su [用户名]切换到其它用户，默认切换到root用户。提示密码为将切换用户密码*-f快速切换，忽略配置文件-l重新登录-m，-p不更改环境变量**-c &lt;命令&gt;切换后执行命令，并退出切换*sudo [命令]以其它用户的身份执行命令，默认以root的身份执行。提示密码为当前用户密码*-s切换为root shell              -i切换为root shell，并初始化-u &lt;用户名|UID&gt;执行命令的身份**-l显示自己的权限*passwd [用户名]设定用户密码*-d清除密码-l锁定用户-e使密码过期，在下次登录时更改密码**-S显示密码认证信息-x &lt;天数&gt;密码过期，最大使用时间**-n &lt;天数&gt;冻结密码，最小使用时间-s更改登录Shell                 -f更改用户信息*示例：$passwdChanging password for user(current) UNIX password: 原密码Enter new UNIX password: 新密码Retype new UNIX password: 确认新密码chsh [-s ] [用户名]更改登录Shellusermod &lt;用户名&gt;修改用户账号*-d &lt;目录&gt;设定$HOME目录-m设定$HOME目录时自动建立**-s 修改用户登录Shell              -l &lt;新用户名&gt;修改为新用户名**-u 修改用户UID                       -g &lt;群组名&gt;修改用户归属群组**-G &lt;群组名&gt;修改用户归属附加群组-L锁定帐户-U解除锁定**-e &lt;过期时间&gt;设定用户账号过期时间-f &lt;缓冲天数&gt;设定密码过期后多长时间关闭账号**-c &lt;字符串&gt;修改用户备注*useradd &lt;用户名&gt;新建用户*-d &lt;目录&gt;设定$HOME目录-m自动建立$HOME目录-M不自动建立$HOME目录**-s 修改用户登录Shell              -l &lt;用户名&gt;修改为新用户名-u 修改用户UID**-g &lt;群组名&gt;修改用户归属群组-G &lt;群组名&gt;修改用户归属附加群组**-n不建立以用户名为名称的群组-e &lt;过期时间&gt;设定用户账号过期时间**-f &lt;缓冲天数&gt;设定密码过期后多长时间关闭账号-c &lt;字符串&gt;修改用户备注**-D [表达式]更改预设值（预设值保存于/etc/default/useradd文件中）*新建用户规则保存于 /etc/login.defs 文件中新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录userdel &lt;用户名&gt;删除用户*-r删除用户相关文件和目录*id [用户名]显示用户 UID GID 归属附加群组finger [用户名]显示用户信息进程管理一些细节进程一般分为交互进程、批处理进程和守护进程三类。守护进程总是活跃，在系统启动时通过脚本自动启动，或由root启动，通常在后台运行。一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。init 进程为根进程，所有进程都是它的子进程ps显示进程信息，参数可省略 -*aux以BSD风格显示进程(常用)                   -efH以System V风格显示进程**-e , -A显示所有进程a显示终端上所有用户的进程x显示无终端进程**u显示详细信息f树状显示w完整显示信息l显示长列表*示例：ps alx 另一种常用输出格式ps aux | less 将输出通过管道，使用 less 查看ps aux | grep &lt;关键字&gt; 通过关键字查找进程输出字段USER   进程所有 者                PID  进程 ID                PPID  父进 程               %CPU CPU占用率%MEM  内存占用率           NI  进程优先级。数值越大，占用CPU时间越 少                   VSZ 进程虚拟大小RSS  页面文件占 用               TTY  终端 ID               STAT 进程状态D 不可中断 Uninterruptible sleep (usually  IO)                R 正在运行，或在队列中的进程S  处于休眠状 态                    T  停止或被追 踪                   Z 僵尸进程W  进入内存交换（从内核2.6开始无 效）           X  死掉的进程             &lt;  高优先 级                  N 低优先级L  有些页被锁进内存          s  包含子进 程               + 位于后台的进程组；l 多线程，克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)pstree树状显示进程信息*-a显示完整命令及参数-c重复进程分别显示-c显示进程ID PID   -n按PID排列进程*pgrep &lt;进程名&gt;显示进程的PID*-l显示进程名和进程PID            -o进程起始ID           -n进程终止ID*xkill在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消pkill &lt;进程名&gt;结束进程族。如果结束单个进程，请用 killkill [信号代码] &lt;进程PID&gt;根据PID向进程发送信号，常用来结束进程，默认信号为 -9-l [信号数字] 显示、翻译信号代码-9 , -KILL 发送 kill 信号退出-6 , -ABRT 发送 abort 信号退出-15 , -TERM 发送 Termination 信号-1 , -HUP 挂起-2 , -INT 从键盘中断，相当于 Ctrl+c-3 , -QUIT 从键盘退出，相当于 Ctrl+d-4 , -ILL 非法指令-11 , -SEGV 内存错误-13 , -PIPE 破坏管道-14 , -ALRM-STOP 停止进程，但不结束-CONT 继续运行已停止的进程-9 -1 结束当前用户的所有进程renice &lt;优先级表达式&gt; &lt;进程表达式&gt;重新设定进程优先级（无此必要）优先级表达式：+|-|=nice取值范围： -20~19进程表达式：-p  通过进程ID进行设定-g  通过进程群组ID-u  通过进程拥有者UID设定top动态、交互式进程管理器-c 显示进程启动状态，包括参数、操作对象等；而不只是进程名-d &lt;秒&gt; 刷新频率。 -d 5，表示5秒刷新一次-n &lt;次&gt; 刷新次数，然后退出。 -n 5，表示刷新5次后退出；-b 以批量模式运行，让输出能够使用管道或重定向。但不能进行交互，最好和 -n &lt;次&gt; 参数一同使用-i 禁止显示空闲进程或僵尸进程；-p PID 仅监视指定进程的ID；PID是一个数值；-s 安全模式运行，禁用一些效互指令；-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；交互命令： 立即刷新k 交互式杀死进程，提示输入进程 PID （默认发送信号15）r 设定renice，提示输入PID和renice值s 改变两次刷新时间间隔，以秒为单位n 设定显示进程数， 0 为不作限制i 隐藏空闲进程和僵尸进程S 切换到累积时间模式l 开关，在顶部显示 uptime 信息t 开关，在顶部显示 进程和CPU状态m 开关，在顶部显示 free 信息c 显示方式切换： 进程名/进程启动状态A 按进程启动顺序进行排序。由新到旧M 按内存占用排序。由大到小N 以进程ID排序。由大到小P 按CPU占用排序。由大到小T 按时间／累积时间排序f ，F 设定显示字段。设定完成后空格退出o,O 设定显示字段的排序。大写向前移动，小写向后移动，空格退出h,? 显示有关安全模式和累积模式的帮助信息W 把当前的配置写到~/.toprc中；nohup &lt;命令&gt;将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。&lt;命令&gt; &amp;背景执行此命令，如果用户退出登录，则命令停止执行&lt;命令1&gt; ; &lt;命令2&gt; ; ......命令队列，从左向右，依次执行以 ; 分隔的命令&lt;命令1&gt; &amp;&amp; &lt;命令2&gt; &amp;&amp; ......命令队列，从左向右，依次执行以 &amp;&amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行&lt;命令&gt; 挂起当前Shell中的任务jobs显示背景任务bg [任务编号]将挂起的任务背景执行fg [任务编号]将背景任务调到前台执行计划任务磁盘和内存管理一些细节Linux中，设备用/dev/目录下的文件表示。例如/dev/hda1 第一块硬盘的第一主分区/dev/hdb5 第二块硬盘的第一逻辑分区/dev/sda4 第一块SATA硬盘的第四主分区，或者扩展分区/dev/null 黑洞设备关于磁盘设备，详见 分区概念mount &lt;设备文件&gt; [挂载路径]挂载文件系统-t 指定文件系统的类型。通常不必指定，mount自动检测。下面是常用的格式reiserfs ReiserFS 3.6版jfs IBM技术xfs SGI技术(适合高级服务器，桌面用户慎用)ext3 Linux传统文件系统vfat fat fat32ext2 不带日志的ext3ntfs WINNTiso9660 光盘smbfs Windows文件共享-o [选项1] [选项2] ......loop 环设备。光盘、ISO镜像等ro | rw 只读readonly；可读写read-writesync | async 同步模式|异步模式。决定修改是否立即写入文件系统atime | noattime 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 *noatime*auto | noauto 自动挂载模式exec | noexec 是否允许可执行权限defaults 使用预设的选项 rw, suid, dev, exec, auto, nouser, asynciocharset=UTF-8 指定字符集，可简写为 utf8codepage=936 指定代码页，可简写为 cp936 西文系统代码页为 437umask=&lt;权限掩码&gt; 设定权限掩码uid= 设定归属用户gid= 设定归属群组remount 以不同选项重新挂载-L &lt;卷标&gt; 将带有特殊卷标的分区Tip权限掩码权限=777-权限掩码（三位） | 7777-权限掩码（四位）假如权限掩码为 022 ，则新建对象权限为 755 rwxr-xr-x可以使用 umask 命令设置权限掩码mount -a挂载 /etc/fstab 文件中定义的所有设备示例：sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdromsudo mount -t vfat -o remount iocharset=utf8,codepage=cp936 /dev/hda5 /media/hda5umount &lt;设备文件&gt; | &lt;挂载路径&gt;卸载已挂载文件系统df查看已挂载文件系统的磁盘空间占用-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统-T   显示文件系统类 型                   -k 以k字节为单位显示               -i 显示i节点信息，而不是磁盘块-t &lt;文件系统类型&gt; 显示指定类型的文件系统的磁盘空间使用情况-x &lt;文件系统类型&gt; 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。-l 只显示本地文件系统free查看内存、缓冲区、交换空间的占用-b  以字节为单位显示数值            -k  以千字节为单位显示数 值                 -m 以兆字节为单位显示数值-g  以吉字节为单位显示数 值                 -l 显示内存占用峰值          -o  不显示缓冲区占 用                    -t 统计结果-s &lt;秒&gt; 刷新频率sync同步文件系统。将缓冲区中的数据写入文件系统fdisk &lt;磁盘设备文件&gt;分区表修改工具交互命令：m   使用帮 助                 l  查看已知文件系统类 型              p 显示分区信息n 新建分区 （p:主分区 l:扩展分区 参见 分区概念  )          d  删除分 区                  t 改变分区类型w 将改动写入分区表                   q 放弃改动并退出\* 磁盘设备名称为整块磁盘，而不是磁盘中的分区。例如 /dev/hda ，而不是 /dev/hda1**fdisk -l**查看所有磁盘分区信息cfdisk更加友善的分区表修改工具mkfs.&lt;文件系统类型&gt; &lt;分区设备文件&gt;将分区格式化为文件系统。 文件系统类型示例：sudo mkfs.reiserfs /dev/hda1mkfs &lt;分区设备文件&gt;-t  &lt;文件系统类型&gt;  指定文件系统类 型                   -c 格式化前检查磁盘**mkisofs -o &lt;镜像文件&gt; [源文件目录]**用光盘或者文件制作iso镜像-b 可启动镜像hdparm &lt;磁盘设备文件&gt;设置硬盘参数-d  &lt;0|1&gt;  DMA模式开 关               -a &lt;0|1&gt;  预计模式开 关                  -t  性能测 试                  -T 缓存性能测试-c &lt;0|1|3&gt;  32位传输模式开 关                -g  显示柱面，扇区等信息            -i -I 显示磁盘信息网络和硬件管理ifconfig配置网络接口-a 显示所有网络接口ifconfig &lt;网卡&gt; up|down激活|禁用网卡示例： ::sudo ifconfig eth0 upifconfig &lt;网卡&gt; add  [ netmask &lt;子网掩码&gt; ]给网卡指定IP地址或子网掩码route配置路由及网关route add -net &lt;路由地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ] dev &lt;网卡&gt;指定路由及网关route del -net &lt;网关地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ]删除路由及网关ip配置网络子命令：link   网卡配 置              address 配置地址。相当于  ifconfig                route 配置路由。相当于 route参数：show  显示(默 认)                  set  设 置              add  添加            del  删除示例：ip link show 显示网卡配置ip link set eth0 name xxx 重命名网络接口ping向目标地址发送ICMP封包，常用来测试网络-b  &lt;广播地址&gt;  ping整个网 段                -c  发送封包次 数                   -s &lt;封包大小&gt; 默认为64字节netstat网络连接状态-r 显示路由表，同  route              -a  所有连 接                 -t  只显示TCP协 议            -U  只显示UDP协议-l  只显示正在监听的端 口            -p  显示PID和进程 名                   -c &lt;秒&gt; 刷新频率\* http/ftp/ssh……  为应用层协 议                   *  TCP/UDP为传输层协 议           *  IP/ICMP为网络层协议lspci查看PCI总线连接的设备lsusb查看USB接口连接的设备lsmod查看已加载模块\* /lib/modules/uname -r 目录下为所有可用模块modprobe &lt;模块名称&gt;简明VIM教程VIM简介我们使用的大多数编辑器，都可以直接在编辑区输入字符，并且能够通过一些快捷键来完成一些控制功能，比如使用方向键移动光标，使用BackSpack 或者 Delete 键删除文字，使用 PgUp 和 PgDn 翻页，使用 Home 和 End 来定位行首和行末……而Vim是一个带模式的编辑器，同样的按键，在不同模式下，具有不同的功能定义。例如 h j k l 在 编辑模式 下输入相应的字符，在 普通模式 下却相当于方向键的作用。由于需要切换模式，Vim的使用起来略显繁琐。不过优点也显而易见：您只要把手安安稳稳的放在打字区就可以了，而不需要使用诸如方向键、排版键、小键盘等需要挪开双手的键位，从而提高了您的效率和专注程度。事实上，Vim的前身Vi诞生的时候，键盘上还没有方向键、排版键和小键盘：）命令使用Vim编辑文件:vi [文件名]vim [文件名]教学模式:vimtutor [语言]vim教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语vimtutor en使用Vim比较文件区别vimdiff [文件1] [文件2] [其它文件]……配置文件Vim的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， &quot; 起始的行为注释行。我们提供的配置项，您直接加入配置文件就可以了您可以先对Vim进行一些简单的配置：&quot;设定文件编码set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936&quot;开启语法加亮syntax on&quot;配色风格colorscheme pablo&quot;设定行距 GUI界面中生效set linespace=4&quot;设定GUI选项&quot;set guioptions=gmrLtT m:菜单 T:工具栏set guioptions=gmrLt&quot;设定Tab键缩进的空格数set tabstop=4&quot;设定编辑器将多少空格视为一个缩进set shiftwidth=4&quot;将缩进转换为空格&quot;set expandtab&quot;设定折叠方式&quot;set foldmethod=indent&quot;以下字符将被视为单词的一部分 (ASCII)：&quot;set iskeyword+=33-47,58-64,91-96,123-128模式介绍Vim常见的模式有： 普通模式 、 插入模式 、 命令模式 ，另外我们也会经常用到 可视模式 。Vim启动时进入 普通模式 ；或者在其它模式下，按下 Esc 键，便可以回到普通模式。使用 vimtutor en 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。按 下 i 键，编辑器底部出现了 -- 插入 -- 或者 -- insert -- ，您进入了插入模式。随便按几下 j 、 k 、 l、  h，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了Vim后，您会认为方向键 太麻烦了，简直不能容忍！好了，现在按下 Esc 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。在普通模式下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样:vnew一个命令能够以一些规则简化，上面的命令也可以写为这种形式:vne现在您的编辑区一定弄的四分五裂，您可以使用命令“:quit”来关闭当前栏，直接用简写就可以了:q这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果您想不执行当前命令，直接回到普通模式，您可以按下Esc键。按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。事实上，可视模式相当于高亮选取文本后的普通模式。可视模式具有子模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。模式切换好了，现在我们总结一下模式间切换的方法其它模式==&gt;普通模式Esc普通模式==&gt;插入模式i  在光标前插入 I  在行首插 入                       a 在光标后插入 A 在行末插入o 在当前行之下新建行 O  在当前行之上新建 行                     r 替换当前字符 R 从当前字符开始替换普通模式==&gt;命令模式    &amp; nbsp;             普通模式==&gt;可视模式         &amp; nbsp;       v  可视模 式                  V 可视块模式 可视块模式移动在普通模式中，您可以使用以下方式移动光标j  向 下                  k  向 上                 l 向右 h l           h  向左 j您可以使用其它更有效率的方式移动光标w 下一个单词词首 W 将特殊符号视为单词的一部分                      b 上一个单词词首 B 同上e 单词末尾 E  同 上              0 行首 ^  行首文字（行首空格之 后）                   $ 行末H  页面顶 部                 M  页面中 部                L 页面底部在其它模式中，您可以使用方向键移动光标，不过我们不推荐您那样作，您可以在配置文件中绑定插入模式下的功能键noremap!noremap!noremap!noremap!………………&lt;作用范围&gt; &lt;键位&gt; &lt;功能&gt;其中，map!绑定的键盘映射，作用于所有模式；inoremap!绑定的映射，仅作用于插入模式。数字参数您也可以使用数字参数，来重复执行。例如100j 执行100次j键，向下100行或者作为跳转的行号、百分比。见下面的浏览部分&lt;行号&gt; Ctrl+g 按行号跳转标记您可以在当前光标处作一个标记，以便快速返回m&lt;标记名称&gt; 定义标记。标记名称为一个字符</code>&lt;标记名称&gt; 返回标记<br>mx 将当前光标处定义为标记 x<br>`x 返回标记 x<br>浏览<br> 下翻一页  下翻半页                 上翻一页  上翻半页<br>gg   文件首 行                 G  文件末 行                 &lt;行号&gt;G 按行号转到相应行<br>&lt;1<del>100&gt;% 按百分比转到相应的行数           zz 将光标所在行调整至页面中间<br> 下卷一行               上卷一行<br>说明：gg 定位到文件首行， V 进入可视行模式， G 定位到文件末行，实现类似“全选”的功能。依次按下 g g V(Shift+v) G(Shift+g)<br>编辑<br>x   剪切当前字 符                             dd 剪切当前行           y  复制可视模式选取字 符            yy  复制当前行<br>p 在光标后粘贴 P  在光标前粘 贴                 u  撤 消                  重做<br>  逐字克隆上一行内 容                       逐字克隆下一行内容<br>寄存器操作<br>Vim可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴<br>“&lt;寄存器名称&gt; 按下“””键和另一个字符键，便可以定义一个寄存器。例如：<br>“a “1<br>定义寄存器后直接进行操作<br>“ayy 将当前行复制到寄存器 a 中<br>“ap 将寄存器 a 中的内容粘贴到光标之后<br>* 通常情况下，寄存器 + ( “ + Shift+= )对应X下的剪贴板。您在其它程序中复制的内容，可以使用 “+p 粘贴到Vim中；您在Vim中，可以使用 “+y 将内容复制到剪贴板，再粘贴到其它程序中<br>* 没有指定寄存器时，Vim使用“无名寄存器”存储内容<br>搜索和替换<br>按下 / 键，编辑器底部会出现 / 符号，接着输入字符串，便可以进行搜索<br>/ 向下搜索 ? 向上搜索<br>n 搜索下一个<br>N 搜索上一个<br>:s/&lt;源字符串&gt;/&lt;目标字符串&gt; 将源字符串替换为目标字符串<br>:s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 替换当前行中所有符合条件的字符串<br>:&lt;行号1&gt;,&lt;行号2&gt;s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 在指定行中进行替换<br>:%s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 全文替换<br>正则表达式<br>在搜索和替换时，可以使用正则表达式进行匹配<br>宏<br>您可以将一系列的操作录制为一个宏，然后执行它<br>q&lt;宏名称&gt; 开始录制宏。宏名称为一个字符<br>q 录制中按下“q”键，结束录制<br>@&lt;宏名称&gt; 执行宏<br>插入模式下的快捷键<br>&lt;寄存器名称&gt; 输入指定寄存器内容<br>&lt;2个字符&gt; 输入二合字符<br>&lt;数字&gt; 通过数字编码输入字符<br>&lt;键位&gt; 输入键位的名称<br>键绑定、缩写<br>前面我们已经向您介绍了键绑定，<br>map!<br>尖括号及其中的内容，为Vim配置文件的约定，分别描述了按键和功能，表示将功能编写到按键上。如果绑定的只是普通字符，例如：<br>map! xxx XXXXX<br>表示将 fXXXXX 绑定到 xxx 上。当您键入 xxx 时，编辑器会自动替换为 XXXXX 。<br>如果您只是想将字符串绑定为缩写，方便输入，我们建议您使用 iabbrev 来绑定。例如：<br>iabbrev ubt Ubuntu<br>在插入模式下键入 ubt ，编辑器会自动替换为 Ubuntu 。您可以将 iabbrev 命令缩写为 iab ，例如：<br>iab ubt Ubuntu<br>以上命令，您可以直接在命令模式下输入，临时启用。也可以写入配置文件，永久启用。<br>单词补全<br> 下一个匹配项<br> 上一个匹配项<br>您可以在配置文件中定义补全的方式<br>“自动补全方式：(使用逗号分隔)<br>set complete=k,.<br>“ . 当前文件<br>“ b 已被装缓冲区,但是没有在窗口内的文件<br>“ d 在当前的文件中定义和由#include包含进来的文件<br>“ i 由#include包含进来的文件<br>“ k 由dictionary选项定义的文件<br>“ kfile 名为{file}的文件<br>“ t 标记(tags)文件<br>“ u 没有载入的缓冲区<br>“ w 在其他窗口中的文件<br>“设定自动补全字典 ：<br>set dictionary=path<br>命令模式<br>前面介绍了普通模式和插入模式。我们发现，普通模式主要用来浏览和修改文本内容，而插入模式则用来向文本中添加内容。<br>而命令模式则多用于操作文本文件（而不是操作文本文件的内容），例如保存文件；或者用来更改编辑器本身的状态，例如设定多栏窗口、标签或者退出编辑器……<br>w(rote) 将更改写入文件<br>:w<br>q(uit) 退出编辑器:<br>:q<br>某些情况下，编辑器会阻止命令的执行。例如您修改了文件，而没有保存，那么您使用 :q 命令退出时，编辑器就不会执行这条命令，而是提醒您保存文件。<br>这个时候，您可以在命令末尾追加 ! 来强制执行命令<br>:&lt;命令&gt;!<br>例如 :q! ，即便您没有保存已修改的文件，使用此命令，编辑器也会放弃修改而强行退出<br>以 ! 引导一个Shell命令，则可以从Vim临时切换到Shell中，执行一个Shell<br>:!&lt;命令&gt;<br>例如 :!ls<br>多栏窗口<br>您可以使用以下命令，将当前窗口水平分为两栏<br>:new<br>新建一栏空白窗口<br>:split<br>将当前文件分两栏显示<br>同理，您可以使用下列命令，将当前窗口垂直分为两栏<br>:vnew<br>:vsplit<br>先按下  键，再按下方向键 j 、 k 、 l 、 h ，您可以切换到其它栏；在当前栏中使用 :q 命令，可以退出当前栏，也可以使用其它命令，对当前栏作出修改<br>如果您希望当前命令在所有栏中生效，您可以在命令的末尾追加 all<br>:&lt;命令&gt;all<br>例如：<br>:qall<br>如果您希望这条命令强制执行，那么 ! 位于命令的最末<br>:&lt;命令&gt;all!<br>例如：<br>:qall! 强行退出所有栏窗口<br>标签页<br>Vim在7以后的版本，开始支持标签页的功能<br>:tabnew 新建一个标签<br>:tabnext 转到下一个标签<br>:tabprevious 转到上一个标签<br>多数情况下，您可以使用鼠标点击标签进行切换。<br>引导管理器Grub<br>硬件基础<br>一块硬盘，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表，您可以阅读分区概念章节中相关内容）<br>每个分区起始的一部分扇区，为分区引导扇区。<br>在分区引导扇区之后的部分，为文件系统的索引，文件系统通过它定位文件在硬盘上的位置。不同的文件系统采用不同的索引，例如FAT文件系统使用文件分配表和目录区。<br>绝大多数操作系统，对硬盘的读写操作，通过文件系统来完成，因此引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。<br>我们对文件进行修改后，操作系统会将文件系统索引中的内容同步。<br>系统引导流程<br>1.系统启动时，首先引导至MBR，将控制权移交安装在MBR中的引导管理器<br>（Windows使用NTLDR，Linux通常用Grub）<br>2.引导管理器读取分区表<br>3.引导管理器读取分区中的配置文件，并按配置文件中预设的参数运行<br>例如，Grub读取“/boot/grub/menu.lst”文件中内容，将可引导系统通过菜单显示<br>4.引导管理器根据您的选择，可能会有如下活动<br>加 载内核，启动Linux系统检查活动分区，并引导它（单一Windows系统）读取相应分区的引导扇区，将控制权移交该扇区中的引导管理器，Ubuntu 系统在安装Grub时，会提问您安装在MBR或者分区引导扇区中。如果将Grub安装在分区引导纪录中，您必须确保MBR中的引导管理器能够正确的引导至 分区引导扇区。<br>如果您在MBR中使用的是Windows的引导管理器NTLDR，完成这件工作会非常困难，因而我们推荐您使用Grub。<br>Grub介绍<br>Grub主要有以下功能：<br>菜单式选择<br>命令行模式<br>支持开机画面<br>支持大硬盘<br>其它的功能还有很多，就不一一介绍了。<br>您可以运行命令 grub 启动它。会显示一些版本信息和使用提示，当然还有命令提示符，如下：<br>GNU GRUB version 0.97 (640K lower / 3072K upper memory)<br>[ Minimal BASH-like line editing is supported. For<br>the first word, TAB lists possible command<br>completions. Anywhere else TAB lists the possible<br>completions of a device/filename. ]<br>grub&gt;<br>您可以使用 TAB 键补全命令和路径，这非常重要，因为Grub中路径表示方式与操作系统是不同的，您可能比较陌生，所以尽量用TAB补全它，既方便，也不容易出错。<br>您可以在 grub&gt; 提示符后按 TAB 键，会将所有可用的命令显示出来。<br>呵呵，是不是有点晕，命令可真不少啊！！！<br>其实我们会用到的命令只有两个，<br>root<br>setup<br>Grub术语<br>在分区概念章节里，我们已经介绍了Linux系统中表示分区的方法 /dev/hda5<br>/dev/hdMN M为a起始的小写字母，表示硬盘序号；N为1起始的数字，表示分区序号<br>Grub中使用的表示方法为 hd0,1<br>hdX,Y X为0起始的数字，表示硬盘序号；Y为0起始的数字，表示分区序号<br>您得留意它们之间的区别：<br>N从1开始计数，X和Y从0开始计数<br>N为1</del>4，它是一个主分区；N为5或大于5，它是第(N-4)个逻辑分区。Y按分区在硬盘上排列的顺序排列，无论它表示的是主分区还是逻辑分区。<br>举例来说：<br>主 主 逻 逻 主<br>/dev/hdMN hda1 hda2 hda5 hda6 hda3<br>hdX,Y hd0,0 hd0,1 hd0,2 hd0,3 hd0,4<br>现在我们来看 root 和 setup 命令的使用：<br>grub&gt;root (hd0,1)<br>这个命令将Grub的根分区定位为 “(hd0,1)”<br>grub&gt;setup (hd0)<br>这个命令表示将Grub安装在“(hd0)”，因为没有指定安装的分区，所以安装位置为MBR<br>Grub的根分区 为Grub配置文件 /boot/grub/menu.lst 所在分区。假如您单独为 /boot 目录挂载了一个分区，那么Grub的根分区通常为您系统中 /boot 目录所在的分区。<br>搞错了根分区，Grub就不能正确读取配置文件，自然不能正确引导。<br>引导分区 ，Windows等系统的引导分区为它的安装分区，Linux系统的引导分区为它的 /boot 目录所在的分区<br>系统根目录所在分区 ，Linux根目录 / 的挂载分区。Linux系统的分区挂载信息保存在文件系统分配表 /etc/fstab 文件中<br>Grub首先读取根分区中的 /boot/grub/menu.lst<br>文件，并转到引导分区，如果是Windows等系统，则将控制权移动分区引导扇区中的启动管理器。如果是Linux系统，则加载内核和设备，并根据<br>/etc/fstab 文件的内容挂载文件系统。<br>看这个例子：（假设Grub安装在MBR中）<br>title Ubuntu<br>root (hd0,0)<br>kernel (hd0,1)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b<br>initrd (hd0,1)/boot/initrd.img-2.6.15-25-686<br>boot<br>Grub的安装位置为 (hd0)<br>root (hd0,0) ，这一行表示Grub的根分区为第一块硬盘的第一个分区 (hd0,0) ，它读取该分区中的配置文件 grub/menu.lst<br>kernel 和 initrd 行中的 (hd0,1) ，表示当前系统的 /boot 目录挂载到第一块硬盘的第二个分区 (hd0,1)<br>kernel 行的 root=/dev/sda3 ，表示当前系统的 / 目录挂载到第一块硬盘的第三个分区 (hd0,2) ，内核根据该分区中的 /etc/fstab 文件来挂载文件系统<br>Grub配置文件<br>/boot/grub/menu.lst 文件，主要由一些下面这样的块构成的<br>title Ubuntu<br>root (hd0,2)<br>kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b<br>initrd (hd0,2)/boot/initrd.img-2.6.15-25-686<br>boot<br>title Windows xp<br>root (hd0,0)<br>makeactive<br>chainloader +1<br>每一块代表一个操作系统，包含下面里几个部分<br>title xxx 标题，title和分隔符后的内容为Grub菜单中显示的条目<br>root (hdX,Y) 引导分区，可以留空，默认为 grub/menu.lst 所在分区（根分区），可以使用 grub&gt;root (hdX,Y) 命令设置，或者在您安装系统时自动设置<br>如果您计划引导至分区引导扇区，如Windows或者Unix系统（Unix和Linux系统，您需要选择将引导管理器安装到分区中），那么需要这样配置<br>makeactive 设置活动分区，系统默认设置，可以删除<br>chainloader +1 链式引导，不要动它。<br>如果以这种方式引导系统，上面 root (hdX,Y) 这一行通常需要配置， (hdX,Y) 为您的系统所在的分区。假如您的Windows在第一块硬盘的第一个分区，则这样写 root (hd0,0)<br>如果您引导的是Linux系统（没有在分区中安装引导管理器，而是安装到MBR），则需要这样配置<br>kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda2 ro splash vga=0x31b<br>initrd (hd0,2)/boot/initrd.img-2.6.15-25-686 设备镜像文件，与上一行保持一致<br>boot 不要动它<br>kernel 这一行最关键，它控制系统内核的加载。行末以 ro 起始的部分为参数（ro只读，splash显示启动画面，vga设定启动屏幕分辨率）<br>之前的部分可以写为这种形式：<br>kernel (hdX,Y)/boot/vmlinuz root=/dev/sdMN<br>(hdX,Y) 通常不是必须的，如果您安装了多个Linux系统，或者 /boot<code>目录与根目录</code>/ 不在一个分区，则应把它写为 /boot 目录所在分区。而后面的 root=/dev/sdMN 为系统根目录 / 所在的分区。<br>initrd 这一行的 (hdX,Y) 与上一行保持一致。<br>Grub安装<br>上面已经向您介绍了Grub的安装，不过更多的侧重理论。现在我们来实践一下，假设您的系统不能引导，您可以尝试下面的方法：）<br>1.<br>\1. 找一张Ubuntu的LiveCD （Knoppix也是不错的选择）<br>\2. 也可以使用安装光盘，启动后在 boot 提示符后输入 linux rescue ，回车进入救援模式。<br>\2. 如果您拥有root权限，命令行提示符为 # ，如果是普通用户，则为 $ 。<br>\1. 在救援模式下，通常你已经具有了root权限<br>b. 如果是LiveCD且没有root权限，请在终端中输入 su<br>命令切换到root，会提问你root的密码。如果不知道root密码，可以使用这个命令 sudo su<br>，只要你知道自己的密码，并且你在ID在sudoer列表中就可以了。<br>\3. 在终端中输入 grub ，会进入到Grub的提示符界面<br>a. 输入命令 root (hd 后按 Tab 键，屏幕上就会列出所有可用选项。比如我的是这样的：<br>Possible disks are: hd0 hd1<br>这表示我装了两块硬盘，如果你只有一块硬盘的话，那么一定是hd0。<br>在 root(hd 后输入 0 ,按 Tab ，会自动补上一个 , ，现在你输入的内容成为这样：<br>root(hd0,<br>再按 Tab 键，会列出所有可用选项，我的是这样的。<br>Possible partitions are:<br>Partition num: 0, Filesystem type unknown, partition type 0x7<br>Partition num: 1, Filesystem type is fat, partition type 0xc<br>Partition num: 2, Filesystem type is reiserfs, partition type 0x83<br>Partition num: 4, Filesystem type is reiserfs, partition type 0x83<br>Partition num: 5, Filesystem type unknown, partition type 0x82<br>Partition num: 6, Filesystem type unknown, partition type 0x7<br>Partition num: 7, Filesystem type is fat, partition type 0xc<br>输入你的选择，比如为 1 ， Tab 一次后，结果是这样的：<br>root (hd1,1)<br>现在回车<br>2.<br>输入命令<br>setup (hd0)<br>将grub安装在mbr中<br>\3. quit 命令退出GRUB<br>Grub使用<br>命令行<br>在Grub启动菜单中，您可以选择您要的选项，按下 e 键，进入到命令行模式<br>修改您的启动参数，完成后回车<br>按 b 键，Grub将以您修改后的参数引导系统。<br>其它<br>在Grub启动菜单中，按下 c 进入命令行模式<br>按下 d 删除当前选中的项<br>FAQ<br>我的D盘到哪里去了？<br>在使用Linux最初的几天里，我感到有些不安。<br>Windows下，我可以把系统装在C盘，软件放在D盘，音乐放在E盘……如果系统出现问题，我只要重装系统就可以了，大部分软件都可以直接使用（养成使<br>用绿色软件是一种好习惯：），而我辛辛苦苦收集起来的电影和音乐，我总是把它们放在一个安全的地方，以免引发失眠的严重后果。<br>其实Linux下硬盘也具有分区的概念，这一点和Windows没有什么不同（分区的概念是由硬盘的物理特性产生的，而不是操作系统）。不同的是，Linux可以将分区挂载到任意的目录下，而不像Windows，您的分区只能够在“我的电脑”里面：）<br>那么这么作有什么好处么？<br>我们来看看Linux和Windows下路径的表示方法：<br>Windows C:\Documents and Settings\Users\Documents\MyDocument<br>Linux /home/User/MyDocument<br>您一定注意到了，在Windows下面，路径中含有盘符“C:”，它通常代表您硬盘上的第一个分区。也就是说，在使用这些文件时，您需要知道它们在硬盘上<br>存储的相关物理细节。而在Linux下，您不需要知道这些，或者说，只要您设定好了分区挂载的目录，您就不需要再去理会什么分区。<br>Windows下的路径包含有分区、目录和文件三部分内容;而Linux下的路径则只有目录和文件，不包含任何分区信息，它的硬件抽象度更高！<br>Linux下的目录用“/”表示，这不标准吧？？<br>完全相反，这才是标准的体现。您只是习惯了Windows的目录符号，但是那并不意味着它是标准的。<br>看看Winodws下，各种位置、路径的表示方法：<br><a href="http://www.ubuntu.org.cn" target="_blank" rel="noopener">http://www.ubuntu.org.cn</a><br><a href="ftp://192.168.0.1" target="_blank" rel="noopener">ftp://192.168.0.1</a><br>c:\Windows<br>file:///C:/Windows/<br>\127.0.0.1$C<br>……………………………………………………………………<br>操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？<br>Linux下的病毒少，是因为Linux的使用者少，骇客显然不愿意浪费气力去攻击没有人使用的操作系统。<br>您可能已经知道了，互联网上用作重要用途的服务器，其中很大一部分是Linux系统，另外的一部分是Unix系统：）如果骇客能够搞掉Linux系统的话，那么整个互联网就会陷于瘫痪！效果似乎更好一些。<br>当然了，您一定会想：骇客也是人，他们也喜欢上网，兔子还不吃窝边草呢……兔子那么笨，连乌龟都跑不过……骇客们可比兔子要聪明的多了！<br>是的，我承认这一点……不过他们也不一定非得把互联网干掉。很多骇客作梦都想入侵美国军方的服务器，美军服务器中的绝密数据，只要1kb，应该就可以买一台顶级的个人电脑了：）<br>如果可以的话，骇客为什么不去入侵美军的服务器，而要入侵您的电脑呢？<br>这是一个很有意思的观点，与之相映成趣，另一种论调也使人侧目：Windows服务器占到了服务器操作系统xx%的份额。<br>或许这个现象可以用80：20法则来解释：）<br>占服务器总数80%的Windows提供了服务总量的20%！<br>请您务必注意，这只是举一个例子，Windows服务器可能永远也不会占到服务器总数的80%！它提供的服务，以我个人的角度，我不认为可以达到20%，而且永远不会有那一天。<br>软件安装繁琐<br>或许您已经看过一些关于Linux软件安装的文章，但是您也不要忽略，此类文章的数量，是不能够和同类Windows文章相比的。<br>当然，使用源码包安装软件确实有点麻烦，但却不一定比Windows下的某些软件复杂。特别要提到，Ubuntu的包管理系统，为您提供了一种高效快捷的<br>软件管理方式，您只要知道您需要什么软件就可以了，甚至不需要关心它存放在网络上的哪一台服务器中，而且绝大多数的软件都可以使用这种方式来安装。<br>详情请参阅 APT<br>如果您有如下需求，您也可以尝试以源码的形式安装软件：<br>您需要某些软件的技术预览版本<br>您想测试您的机器的运算能力<br>您找不到一种比安装软件更好的方式来消磨时间 | （试图通过编译源码安装来大幅提高系统性能，其结果很可能会让您失望）<br>源码保密性不强，存在安全隐患<br>既然Linux下软件都开放源代码，那么会不会造成一些安全隐患呢？比如说一名骇客会发现其中的漏洞，并利用它？<br>事实刚好相反，一个软件，即便它不开放源码，骇客一样可以找到其中的漏洞，雷蒙德的软件巨头就是最好的佐证。就像一把锁，无论如何坚固，它总是能被撬开！它的作用无外乎“聊备一格，以防君子”：）<br>而这把锁，防住的恰恰是能够改进它的工程师！工程师知道了它的漏洞，却不能够去改进它;骇客知道了它的漏洞，却可以利用它……这把锁正是封闭源码！<br>这岂不是不妙？<br>软件功能不够强<br>虽然您很愿意使用Linux系统，但是它的软件并不能使您满意，甚至使您多愁善感的心灵又蒙上了一层阴影，“长太息以掩涕……”<br>首先您别忘了，《泰坦尼克》的特效就是在Linux系统下完成的，连业界巨头SGI都在向Linux迁移（尽管SGI的IRIX本来就是一种Unix系统）。如果您不知道SoftImage，那么Maya您总听说过吧？它最初就是多平台的。<br>对 于电影特效处理时需要的高吞吐量的数据（以TB计）和运算能力，Windows系统恐怕连崩溃的机会都没有=_=#(最新统计资料显示，Top500计算 机中，使用Linux的占到73.4%，包括最快的前两名。其中Linux系统367部，Unix系统98部，混合操作系统24部，AppleMacOS 系统5部,BSD系统4部，Windows系统，2部）类似于大气模拟、基因解码等等真正的科学运算……Windows……前几天我还在 verycd.com上看到一套欧洲某天文台的天文学软件，只有Linux版！<br>当然了，Linux下功能强大的软件大多是命令行的，图形界面的程序只能视觉上强大，外强中干！建议您多使用man这个命令来查询各类软件的使用方法，它排版美观，格式工整，语法简明，意韵流畅，实在是学习英语难得的教材。<br>界面不友好<br>如果您指的是系统的美观程度。Gnome默认效果我认为与Windows处于同一水平线，而KDE的效果就要略好一点，很多高手用FVWM可以作出让人眼花瞭乱的效果来……而Novell的XGL，更是可以用“惊艳”来形容。<br>如果您指的是操作，这属于“易于上手难于精通”与“难于上手易于精通”两种理念的冲撞。<br>当然了，我指的精通主要针对效率而言。如果您经常玩Blizzard出品的游戏，您对于“易于上手难于精通”这种理念或许相当了解，甚至非常欣赏。<br>不过这一理念只适用于竞技游戏！竞技游戏要球能够吸引大量的玩家，所以要易于上手。但是竞技游戏是为竞技而生的，所以不可能人人是高手 ────事实上高手只是一小部分人！<br>而操作系统是给人们来用的，最好人人都成为高手，所以易于精通是很重要的……当然最好也能够易于上手。但是考虑到效率的问题，这很难解决……<br>Linux怎么占用这么多内存？<br>Linux会最大程度的利用物理内存，避免使用交换空间;而不是尽量的回收内存，使用页面文件。<br>又因为Linux系统的内存管理非常优秀，程序退出时可以高效的回收内存，所以更加没有必要在程序运行时就回收内存！<br>因此，Linux系统表面看来内存开销很大，实际上系统运行是很稳定的──Linux不会时而流畅，时而瘫痪。事实上，在正常情况下，它运行是非常流畅的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu完全教程，让你成为Ubuntu高手！&quot;&gt;&lt;a href=&quot;#Ubuntu完全教程，让你成为Ubuntu高手！&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu完全教程，让你成为Ubuntu高手！&quot;&gt;&lt;/a&gt;Ubuntu完全教程，让你成
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第一个BLOG</title>
    <link href="http://yoursite.com/2020/02/03/%E7%AC%AC%E4%B8%80%E4%B8%AABLOG/"/>
    <id>http://yoursite.com/2020/02/03/%E7%AC%AC%E4%B8%80%E4%B8%AABLOG/</id>
    <published>2020-02-03T12:34:57.000Z</published>
    <updated>2020-02-03T12:36:20.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于考研的谈话"><a href="#关于考研的谈话" class="headerlink" title="关于考研的谈话"></a>关于考研的谈话</h1><h2 id="先选导师在选学校"><a href="#先选导师在选学校" class="headerlink" title="先选导师在选学校"></a>先选导师在选学校</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关于我们学校没有保研的名额,所以只能通过</span><br><span class="line">考研的方式,取得研究生学位</span><br><span class="line">直博:如果博士没能毕业,那么也不会有硕士学位,有硕博连读</span><br></pre></td></tr></table></figure><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">职业罗盘分析</span><br><span class="line">通过爬取招聘信息,来进行大数据分析</span><br><span class="line">总结出每个职业需要什么证</span><br><span class="line">哪些证受企业欢迎 </span><br><span class="line">职业信息匹配</span><br></pre></td></tr></table></figure><h3 id="质变需要量变"><a href="#质变需要量变" class="headerlink" title="质变需要量变"></a>质变需要量变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">很多大学生急于求成,但最后也是一事无成,</span><br><span class="line">对于很多起点比你高的人,想要去追他们,你必须付出更多的努力,从弹钢琴的故事出发,10000小时定理,职业弹钢琴的人在不断的增加练习时间,有的人保持自己每天的练习时间,业余的人在不断减少自己的练习时间</span><br><span class="line">从而职业的人离10000小时的目标越来越近</span><br><span class="line">从写代码的角度出发只有增加自己每天写代码的时间才会成长得快,如果每天甚至没有写代码的习惯,那在这方面基本不会成功</span><br><span class="line">在LEETCODE上做题,每个算法都做上30~40题,包括归并算法,贪心算法,动态规划问题,</span><br><span class="line">大概在半年左右能完成.</span><br><span class="line"></span><br><span class="line">我想的是把编程当作习惯来做</span><br></pre></td></tr></table></figure><h2 id="CCF学会"><a href="#CCF学会" class="headerlink" title="CCF学会"></a>CCF学会</h2><p>  大概每年需要50元, 有十期的学报</p><h3 id="和通信的学生交流"><a href="#和通信的学生交流" class="headerlink" title="和通信的学生交流"></a>和通信的学生交流</h3><h3 id="TensorFlow和Numpy-生成图像的分析结果"><a href="#TensorFlow和Numpy-生成图像的分析结果" class="headerlink" title="TensorFlow和Numpy 生成图像的分析结果"></a>TensorFlow和Numpy 生成图像的分析结果</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于考研的谈话&quot;&gt;&lt;a href=&quot;#关于考研的谈话&quot; class=&quot;headerlink&quot; title=&quot;关于考研的谈话&quot;&gt;&lt;/a&gt;关于考研的谈话&lt;/h1&gt;&lt;h2 id=&quot;先选导师在选学校&quot;&gt;&lt;a href=&quot;#先选导师在选学校&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/03/hello-world/"/>
    <id>http://yoursite.com/2020/02/03/hello-world/</id>
    <published>2020-02-03T03:10:31.470Z</published>
    <updated>2020-02-03T03:10:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

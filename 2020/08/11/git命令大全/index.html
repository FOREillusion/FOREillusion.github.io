<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>git命令大全 | PETER TANG</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="PETER TANG,c++,Golang,Java,Android,后端,前端,全栈,设计,Hexo主题,前端开发,用户体验,设计,算法,frontend,design,nodejs,JavaScript,docker" />
  

  <meta name="description" content="git命令大全 前言最近在学习 Git 命令，发现网上的命令要么排版不清晰，要么不是很全。于是整理出了这篇 Git 命令大全！相信这份 Git 命令，一定值得你收藏。文章内容较多，可以在右侧目录直接找自己需要的部分查看。文章会持续更新，欢迎大家点赞，收藏！ 这里还有一个偷懒的小技巧 hh，如果你不想记住那么多 Git 命令，你可以看看我的这篇文章：VScode 结合 git 的全面使用流程，再也不">
<meta property="og:type" content="article">
<meta property="og:title" content="git命令大全">
<meta property="og:url" content="http://yoursite.com/2020/08/11/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/index.html">
<meta property="og:site_name" content="PETER TANG">
<meta property="og:description" content="git命令大全 前言最近在学习 Git 命令，发现网上的命令要么排版不清晰，要么不是很全。于是整理出了这篇 Git 命令大全！相信这份 Git 命令，一定值得你收藏。文章内容较多，可以在右侧目录直接找自己需要的部分查看。文章会持续更新，欢迎大家点赞，收藏！ 这里还有一个偷懒的小技巧 hh，如果你不想记住那么多 Git 命令，你可以看看我的这篇文章：VScode 结合 git 的全面使用流程，再也不">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-11T15:11:50.000Z">
<meta property="article:modified_time" content="2020-08-11T15:12:48.645Z">
<meta property="article:author" content="PETER TANG">
<meta name="twitter:card" content="summary">

  

  
    <link rel="icon" href="/sunny.svg">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="PETER TANG" type="application/atom+xml">
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Git-安装配置"><span class="toc-text">1.Git 安装配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1Linux-平台上安装"><span class="toc-text">1.1Linux 平台上安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Windows-平台上安装"><span class="toc-text">1.2 Windows 平台上安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3Mac-平台上安装"><span class="toc-text">1.3Mac 平台上安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Git-配置"><span class="toc-text">1.4 Git 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Git-创建仓库"><span class="toc-text">2.Git 创建仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Git-基本操作"><span class="toc-text">3. Git 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-获取与创建项目命令"><span class="toc-text">3.1 获取与创建项目命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-基本快照"><span class="toc-text">3.2 基本快照</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#On-branch-master"><span class="toc-text">On branch master</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Viper-Git-测试"><span class="toc-text">Viper Git 测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#菜鸟教程"><span class="toc-text">菜鸟教程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#提交到-Github"><span class="toc-text">提交到 Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#菜鸟教程-Git-测试"><span class="toc-text">菜鸟教程 Git 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一次修改内容"><span class="toc-text">第一次修改内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#添加仓库-origin2"><span class="toc-text">添加仓库 origin2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#删除仓库-origin2"><span class="toc-text">删除仓库 origin2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#github-com-22-SSH-2-0-babeld-d45c1532"><span class="toc-text">github.com:22 SSH-2.0-babeld-d45c1532</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-git命令大全" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">git命令大全</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.08.11</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>PETER TANG</span>
        </span>
      

      


      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>git命令大全</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习 Git 命令，发现网上的命令要么排版不清晰，要么不是很全。于是整理出了这篇 Git 命令大全！相信这份 Git 命令，一定值得你收藏。文章内容较多，可以在右侧目录直接找自己需要的部分查看。文章会持续更新，欢迎大家点赞，收藏！</p>
<p>这里还有一个偷懒的小技巧 hh，如果你不想记住那么多 Git 命令，你可以看看我的这篇文章：VScode 结合 git 的全面使用流程，再也不用记住 git 的命令了！</p>
<p>VsCode 已经封装好了 Git 命令，我们只要学会怎么使用就好了，是不是很方便呢！</p>
<p>如果你想学习 Linux 命令，我的另外一篇文章也能帮到你：Linux 命令大全（排版清晰！！持续更新！！非常详细）</p>
<h2 id="1-Git-安装配置"><a href="#1-Git-安装配置" class="headerlink" title="1.Git 安装配置"></a>1.Git 安装配置</h2><p>在使用 Git 前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac 和 Windows 平台上运行。</p>
<p>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">http://git-scm.com/downloads</a></p>
<h3 id="1-1Linux-平台上安装"><a href="#1-1Linux-平台上安装" class="headerlink" title="1.1Linux 平台上安装"></a>1.1Linux 平台上安装</h3><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p>
<p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p>
<p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p>
<p>Debian/Ubuntu<br>Debian/Ubuntu Git 安装命令为：</p>
<p>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext <br>  libz-dev libssl-dev</p>
<p>$ apt-get install git</p>
<p>$ git –version<br>git version 1.8.1.2<br>Centos/RedHat<br>如果你使用的系统是 Centos/RedHat 安装命令为：</p>
<p>$ yum install curl-devel expat-devel gettext-devel <br>  openssl-devel zlib-devel</p>
<p>$ yum -y install git-core</p>
<p>$ git –version<br>git version 1.7.1<br>源码安装<br>我们也可以在官网下载源码包来安装，最新源码包下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p>
<p>安装指定系统的依赖包：</p>
<p>########## Centos/RedHat ##########<br>$ yum install curl-devel expat-devel gettext-devel <br>  openssl-devel zlib-devel</p>
<p>########## Debian/Ubuntu ##########<br>$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext <br>  libz-dev libssl-dev<br>解压安装下载的源码包：</p>
<p>$ tar -zxf git-1.7.2.2.tar.gz<br>$ cd git-1.7.2.2<br>$ make prefix=/usr/local all<br>$ sudo make prefix=/usr/local install</p>
<h3 id="1-2-Windows-平台上安装"><a href="#1-2-Windows-平台上安装" class="headerlink" title="1.2 Windows 平台上安装"></a>1.2 Windows 平台上安装</h3><p>在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：</p>
<p>安装包下载地址：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p>
<p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p>
<p>在开始菜单里找到 “Git”-&gt;“Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p>
<h3 id="1-3Mac-平台上安装"><a href="#1-3Mac-平台上安装" class="headerlink" title="1.3Mac 平台上安装"></a>1.3Mac 平台上安装</h3><p>在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为：</p>
<p><a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">http://sourceforge.net/projects/git-osx-installer/</a></p>
<p>安装界面如下所示：</p>
<h3 id="1-4-Git-配置"><a href="#1-4-Git-配置" class="headerlink" title="1.4 Git 配置"></a>1.4 Git 配置</h3><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p>
<p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。<br>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。<br>当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。<br>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。</p>
<p>此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<p>用户信息<br>配置个人的用户名称和电子邮件地址：</p>
<p>$ git config –global user.name “Viper”<br>$ git config –global user.email <a href="mailto:test@Viper.com">test@Viper.com</a><br>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p>
<p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p>
<p>文本编辑器<br>设置 Git 默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:</p>
<p>$ git config –global core.editor emacs<br>差异分析工具<br>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p>
<p>$ git config –global merge.tool vimdiff<br>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p>
<p>当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p>
<p>查看配置信息<br>要检查已有的配置信息，可以使用 git config –list 命令：</p>
<p>$ git config –list<br>http.postbuffer=2M<br>user.name=Viper<br>user.email=test@Viper.com<br>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。</p>
<p>这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示：</p>
<p>vim ~/.gitconfig<br>显示内容如下所示：</p>
<p>[http]<br>    postBuffer = 2M<br>[user]<br>    name = Viper<br>    email = <a href="mailto:test@Viper.com">test@Viper.com</a><br>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p>
<p>$ git config user.name<br>Viper</p>
<h2 id="2-Git-创建仓库"><a href="#2-Git-创建仓库" class="headerlink" title="2.Git 创建仓库"></a>2.Git 创建仓库</h2><p>本章节我们将为大家介绍如何创建一个 Git 仓库。</p>
<p>你可以使用一个已经存在的目录作为 Git 仓库。</p>
<p>git init<br>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。</p>
<p>在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p>
<p>使用方法<br>使用当前目录作为 Git 仓库，我们只需使它初始化。</p>
<p>git init<br>该命令执行完后会在当前目录生成一个 .git 目录。</p>
<p>使用我们指定目录作为 Git 仓库。</p>
<p>git init newrepo<br>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<p>$ git add *.c<br>$ git add README<br>$ git commit -m ‘初始化项目版本’<br>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>
<p>git clone<br>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。</p>
<p>克隆仓库的命令格式为：</p>
<p>git clone <repo><br>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<p>git clone <repo> <directory><br>参数说明：</p>
<p><strong>repo:</strong>Git 仓库。<br><strong>directory:</strong> 本地目录。<br>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<p>$ git clone git://github.com/schacon/grit.git<br>执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>
<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<p>$ git clone git://github.com/schacon/grit.git mygrit</p>
<h2 id="3-Git-基本操作"><a href="#3-Git-基本操作" class="headerlink" title="3. Git 基本操作"></a>3. Git 基本操作</h2><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目快照的命令作介绍。</p>
<h3 id="3-1-获取与创建项目命令"><a href="#3-1-获取与创建项目命令" class="headerlink" title="3.1 获取与创建项目命令"></a>3.1 获取与创建项目命令</h3><p>git init<br>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。</p>
<p>在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 Viper 项目：</p>
<p>$ mkdir Viper<br>$ cd Viper/<br>$ git init<br>Initialized empty Git repository in /Users/tianqixin/www/Viper/.git/<br>在 /www/Viper/.git/ 目录初始化空 Git 仓库完毕。<br>现在你可以看到在你的项目中生成了 .git 这个子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。</p>
<p>ls -a<br>.    ..    .git<br>git clone<br>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p>
<p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p>
<p>git clone [url]<br>[url] 为你想要复制的项目，就可以了。</p>
<p>例如我们克隆 Github 上的项目：</p>
<p>$ git clone <a href="mailto:git@github.com">git@github.com</a>:schacon/simplegit.git<br>Cloning into ‘simplegit’…<br>remote: Counting objects: 13, done.<br>remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13<br>Receiving objects: 100% (13/13), done.<br>Resolving deltas: 100% (2/2), done.<br>Checking connectivity… done.<br>克隆完成后，在当前目录下会生成一个 simplegit 目录：</p>
<p>$ cd simplegit/<br>$ ls<br>README   Rakefile lib<br>上述操作将复制该项目的全部记录。</p>
<p>$ ls -a<br>.        ..       .git     README   Rakefile lib<br>$ cd .git<br>$ ls<br>HEAD        description info        packed-refs<br>branches    hooks       logs        refs<br>config      index       objects<br>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p>
<h3 id="3-2-基本快照"><a href="#3-2-基本快照" class="headerlink" title="3.2 基本快照"></a>3.2 基本快照</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。本章将对有关创建与提交你的项目的快照的命令作介绍。</p>
<p>git add<br>git add 命令可将该文件添加到缓存，如我们添加以下两个文件：</p>
<p>$ touch README<br>$ touch hello.php<br>$ ls<br>README        hello.php<br>$ git status -s<br>?? README<br>?? hello.php<br>$<br>git status 命令用于查看项目的当前状态。</p>
<p>接下来我们执行 git add 命令来添加文件：</p>
<p>$ git add README hello.php<br>现在我们再执行 git status，就可以看到这两个文件已经加上去了。</p>
<p>$ git status -s<br>A  README<br>A  hello.php<br>$<br>新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。</p>
<p>现在我们修改 README 文件：</p>
<p>$ vim README<br>在 README 添加以下内容：# Viper Git 测试，然后保存退出。</p>
<p>再执行一下 git status：</p>
<p>$ git status -s<br>AM README<br>A  hello.php<br>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行 git add 命令将其添加到缓存中：</p>
<p>$ git add .<br>$ git status -s<br>A  README<br>A  hello.php<br>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。</p>
<p>git status<br>git status 以查看在你上次提交之后是否有修改。</p>
<p>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：</p>
<p>$ git status<br>On branch master</p>
<p>Initial commit</p>
<p>Changes to be committed:<br>  (use “git rm –cached <file>…” to unstage)</p>
<pre><code>new file:   README
new file:   hello.php</code></pre><p>git diff<br>执行 git diff 来查看执行 git status 的结果的详细信息。</p>
<p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p>
<p>尚未缓存的改动：git diff<br>查看已缓存的改动： git diff –cached<br>查看已缓存的与未缓存的所有改动：git diff HEAD<br>显示摘要而非整个 diff：git diff –stat<br>在 hello.php 文件中输入以下内容：</p>
<?php
echo '菜鸟教程：www.Runoob.com';
?>
<p>$ git status -s<br>A  README<br>AM hello.php<br>$ git diff<br>diff –git a/hello.php b/hello.php<br>index e69de29..69b5711 100644<br>— a/hello.php<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php
+echo '菜鸟教程：www.Runoob.com';
+?><br>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</p>
<p>接下来我们来查看下 git diff –cached 的执行效果：</p>
<p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git diff –cached<br>diff –git a/README b/README<br>new file mode 100644<br>index 0000000..8f87495<br>— /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+# Viper Git 测试<br>diff –git a/hello.php b/hello.php<br>new file mode 100644<br>index 0000000..69b5711<br>— /dev/null<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+<?php
+echo '菜鸟教程：www.Runoob.com';
+?><br>git commit<br>使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。</p>
<p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。</p>
<p>$ git config –global user.name ‘Viper’<br>$ git config –global user.email <a href="mailto:test@Viper.com">test@Viper.com</a><br>接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。</p>
<p>$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) d32cf1f] 第一次版本提交<br> 2 files changed, 4 insertions(+)<br> create mode 100644 README<br> create mode 100644 hello.php<br>现在我们已经记录了快照。如果我们再执行 git status:</p>
<p>$ git status</p>
<h1 id="On-branch-master"><a href="#On-branch-master" class="headerlink" title="On branch master"></a>On branch master</h1><p>nothing to commit (working directory clean)<br>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个 “working directory clean：干净的工作目录”。</p>
<p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &#39;#&#39; will be ignored, and an empty message aborts the commit.</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line"># modified:   hello.php</span><br><span class="line">#</span><br></pre></td></tr></table></figure>
<p>~<br>“.git/COMMIT_EDITMSG” 9L, 257C<br>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p>
<p>git commit -a<br>我们先修改 hello.php 文件为以下内容：</p>
<?php
echo '菜鸟教程：www.Runoob.com';
echo '菜鸟教程：www.Runoob.com';
?>
<p>再执行以下命令：</p>
<p>git commit -am ‘修改 hello.php 文件’<br>[master 71ee2cb] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>git reset HEAD<br>git reset HEAD 命令用于取消已缓存的内容。</p>
<p>我们先改动文件 README 文件，内容如下：</p>
<h1 id="Viper-Git-测试"><a href="#Viper-Git-测试" class="headerlink" title="Viper Git 测试"></a>Viper Git 测试</h1><h1 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h1><p>hello.php 文件修改为：</p>
<?php
echo '菜鸟教程：www.Runoob.com';
echo '菜鸟教程：www.Runoob.com';
echo '菜鸟教程：www.Runoob.com';
?>
<p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：</p>
<p>$ git status -s<br> M README<br> M hello.php<br>$ git add .<br>$ git status -s<br>M  README<br>M  hello.php<br>$ git reset HEAD hello.php<br>Unstaged changes after reset:<br>M    hello.php<br>$ git status -s<br>M  README<br> M hello.php<br>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。</p>
<p>$ git commit -m ‘修改’<br>[master f50cfda] 修改<br> 1 file changed, 1 insertion(+)<br>$ git status -s<br> M hello.php<br>可以看到 hello.php 文件的修改并未提交。</p>
<p>这时我们可以使用以下命令将 hello.php 的修改提交：</p>
<p>$ git commit -am ‘修改 hello.php 文件’<br>[master 760f74d] 修改 hello.php 文件<br> 1 file changed, 1 insertion(+)<br>$ git status<br>On branch master<br>nothing to commit, working directory clean<br>简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。</p>
<p>git rm<br>如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。</p>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p>
<p>git rm <file><br>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</p>
<p>git rm -f <file><br>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可</p>
<p>git rm –cached <file><br>如我们删除 hello.php 文件：</p>
<p>$ git rm hello.php<br>rm ‘hello.php’<br>$ ls<br>README<br>不从工作区中删除文件：</p>
<p>$ git rm –cached README<br>rm ‘README’<br>$ ls<br>README<br>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p>
<p>git rm –r *<br>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。</p>
<p>git mv<br>git mv 命令用于移动或重命名一个文件、目录、软连接。</p>
<p>我们先把刚移除的 README 添加回来：</p>
<p>$ git add README<br>然后对其重名:</p>
<p>$ git mv README  README.md<br>$ ls<br>README.md<br>4. 再按照作用重新整理一下命令<br>（这部分命令和上面的有重复，排版的方式不一样）</p>
<p>一、Git 配置相关<br>如果你首次使用 Git，那刚开始首先是需要配置各种身份信息的，这样当你提交相关任务的时候，别人才能知道这个 commit 是谁提交的。</p>
<p>Git 最小配置<br>1、配置全局账户，也就是该账户对所有的 Git 仓库都有效</p>
<p>git config –global user.name ‘你的账户名称’<br>git config –global user.email ‘你的 Email’<br>2、配置局部账户，也就是该账户只对当前 Git 仓库有效</p>
<p>git config –local user.name ‘你的账户名称’<br>git config –local user.email ‘你的 Email’<br>注意，不同点就是一个参数是 global（全局），一个是 local(本地)</p>
<p>3、查看相关配置情况</p>
<p>配置了之后，显然有时候是需要查看我们当前配置的相关情况的，可以使用如下命令</p>
<p>1、查看 global 类型的配置情况</p>
<p>git config –global –list<br>2、查看某个仓库下的配置情况</p>
<p>git config –local –list<br>二、本地基本操作<br>1、基本操作<br>1、查看变更情况</p>
<p>git status<br>2、查看当前工作在哪个分支上</p>
<p>git branch -v<br>3、切换到指定分支</p>
<p>git checkout 指定分支的名称<br>4、把当前目录及其子目录下所有变更都加入到暂存区</p>
<p>git add . // 注意，add 后面是一个 ‘.’；<br>5、把仓库内所有变更都假如到暂存区</p>
<p>git add -A<br>6、把指定文件添加到暂存区</p>
<p>git add 文件1 文件2 … 文件n<br>7、创建正式的 commit，也就是把当前的数据提交上去</p>
<p>git commit<br>2、比较差异<br>1、比较某文件工作区和暂存区的差异</p>
<p>git diff 某文件<br>2、比较某文件暂存区和 HEAD 的差异</p>
<p>git diff –cache 某文件<br>3、比较工作区和暂存区的所有差异</p>
<p>git diff<br>4、比较暂存区和 HEAD 的所有差异</p>
<p>git diff –cache<br>3、暂存区与工作区之间回滚<br>1、把工作区指定文件恢复成和暂存区一样</p>
<p>git checkout 文件1 文件2 … 文件n<br>2、把暂存区指定文件回复和 HEAD 一样</p>
<p>git reset 文件1 文件2 … 文件n<br>3、把暂存区和工作区所有文件恢复成和 HEAD 一样</p>
<p>git reset –hard<br>4、用 difftool 比较任意两个 commit 的差异</p>
<p>git difftool commit1 commit2<br>注意，从工作区回滚到暂存区则用 checkout ，否则用 reset</p>
<p>4、其他<br>查看哪些文件没有被 Git 管控</p>
<p>git ls-files –others<br>三、加塞临时任务处理<br>1、把未处理完的变更先保存到 stash 中</p>
<p>git stash<br>2、临时任务处理完后继续之前的工作</p>
<p>git stash pop // pop 相当于栈的出栈和入栈一样，把之前的任务弹出来<br>或者<br>git stash apply // 和 pop 不同的是， apply 相当于从栈顶把任务取出来，但是不过从栈中把任务移除<br>3、查看所有的 stash</p>
<p>git stash list<br>4、取回某次 stash 的变更</p>
<p>git stash pop stash @{数字n}<br>四、修改个人分支历史<br>我们的仓库的内容每次变更执行 commit 的时候，都会生成一个新的 commit，不过有时候，我们不想产生新的 commit，而是想要通过修改之前的 commit 来变更仓库的内容，那么就可以使用如下命令了</p>
<p>1、修改最后一次 commit</p>
<p>1、在工作区中修改文件<br>2、git add<br>3、git commit –amend<br>2|、修改中间的 commit(假设代号为 X)</p>
<ol>
<li>git rebase -i X前面的一个 commit 的 id</li>
<li>在工作区修改文件</li>
<li>git add</li>
<li>git rebase –contiue<br>五、查看变更日志等<br>1、当前分支各个 commit 用一行显示</li>
</ol>
<p>git log –online<br>2、显示最近的 n 个 commit</p>
<p>git log -n<br>3、用图示显示所有的分支历史</p>
<p>git log –online –graph –all<br>4、查看涉及到某文件变更的所有 commit</p>
<p>git log 某文件<br>5、某文件各行最后修改对应的 commit 以及作者</p>
<p>git blame 某文件<br>六、分支与标签<br>1、创建新分支<br>基于当前分支创建新分支</p>
<p>git branch 新分支<br>基于指定分支创建新分支</p>
<p>git branch 新分支 已有分支<br>基于某个 commit 创建分支</p>
<p>git branch 新分支 某个 commit 的id<br>创建分支并且切换到该分支</p>
<p>git chechout -b 新分支<br>2、列出分支<br>列出本地分支</p>
<p>git branch -v<br>列出本地和远端分支</p>
<p>git branch -av<br>列出远端所有分支</p>
<p>git branch -rv<br>列出名称符号某样式的远端分支</p>
<p>git branch -rv -l ‘某样式’<br>3、删除分支<br>安全删除本地某分支</p>
<p>git branch -d 要删除的分支<br>强行删除本地分支</p>
<p>git branch -D 要删除的分支<br>删除已合并到 master 分支的所有本地分支</p>
<p>git branch –merged master | grep -v ‘^*| master’ | xargs -n 1 git branch -d<br>删除远端 origin 已不存在的所有本地分支</p>
<p>git remote prune origin<br>4、打标签<br>从 commit 打上标签</p>
<p>git tag 标签名 commit 的id<br>七、两分支之间的集成<br>1、把 A 分支合入到当前分支，且为 merge 创建 commit</p>
<p>git merge A分支<br>2、把 A 分支合入到 B 分支，且为 Merge 创建 commit</p>
<p>git merge A分支 B分支<br>3、把当前分支基于 B 分支做 rebase，以便把 B 分支合入到当前分支</p>
<p>git rebase B分支<br>4、把 A 分支基于 B 分支做 rebase，以便把 B 分支合入到 A 分支</p>
<p>git rebase B分支 A分支<br>5、用 mergetool 解决冲突</p>
<p>git mergetool<br>八、和远端交互<br>1、列出所有 remote</p>
<p>git remote -v<br>2、增加 remote</p>
<p>git remote add url地址<br>3、删除 remote</p>
<p>git remote remove remote的名称<br>4、改变 remote 的 name</p>
<p>git remote rename 旧名称 新名称<br>5、把远端所有分支和标签的变更都拉到本地</p>
<p>git fetch remote<br>6、把远端分支的变更拉倒本地，且 merge 到本地分支</p>
<p>git pull remote名称 分支名<br>7、把本地分支 push 到远端</p>
<p>git push remote名称 分支名<br>8、删除远端分支</p>
<p>git push remote –delete 远端分支名<br>或者<br>git push remote:远端分支名<br>9、向远端提交指定标签</p>
<p>git push remote 标签名<br>10、向远端提交所有标签</p>
<p>git push remote –tags<br>九、常用回滚操作系统<br>未执行 commit 之前<br>1、如果文件修改了，但是还没有添加到暂存区，也就是还没有执行 git add 操作，则可以使用 checkout 来回滚</p>
<p>git chechout – filename<br>2、如果已经添加到暂存区，则可以用 reset 来撤销</p>
<p>git reset HEAD filename<br>执行了 commit 之后<br>1、使用 revert 来撤销某次提交</p>
<p>git revert commitID<br>// 注：git revert 命令是撤销某次操作，而在此次操作之前和之后的提交记录都会保留<br>2、使用 reset 直接回滚到某个版本</p>
<p>git  reset –hard  commit_id<br>// –hard – 强制将缓存区和工作目录都同步到你指定的提交<br>这个操作不可逆，会把 commit_id 之后的全部回滚</p>
<ol start="5">
<li>Git 分支管理<br>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</li>
</ol>
<p>有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p>
<p>创建分支命令：</p>
<p>git branch (branchname)<br>切换分支命令:</p>
<p>git checkout (branchname)<br>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>
<p>合并分支命令:</p>
<p>git merge<br>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p>
<p>开始前我们先创建一个测试目录：</p>
<p>$ mkdir gitdemo<br>$ cd gitdemo/<br>$ git init<br>Initialized empty Git repository…<br>$ touch README<br>$ git add README<br>$ git commit -m ‘第一次版本提交’<br>[master (root-commit) 3b58100] 第一次版本提交<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 README<br>5.1 列出分支<br>列出分支基本命令：</p>
<p>git branch<br>没有参数时，git branch 会列出你在本地的分支。</p>
<p>$ git branch</p>
<ul>
<li>master<br>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。</li>
</ul>
<p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。</p>
<p>如果我们要手动创建一个分支。执行 git branch (branchname) 即可。</p>
<p>$ git branch testing<br>$ git branch</p>
<ul>
<li>master<br>testing<br>现在我们可以看到，有了一个新分支 testing。</li>
</ul>
<p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p>
<p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p>
<p>$ ls<br>README<br>$ echo ‘Viper.com’ &gt; test.txt<br>$ git add .<br>$ git commit -m ‘add test.txt’<br>[master 3e92c19] add test.txt<br> 1 file changed, 1 insertion(+)<br> create mode 100644 test.txt<br>$ ls<br>README        test.txt<br>$ git checkout testing<br>Switched to branch ‘testing’<br>$ ls<br>README<br>当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。</p>
<p>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>
<p>$ git checkout -b newtest<br>Switched to a new branch ‘newtest’<br>$ git rm test.txt<br>rm ‘test.txt’<br>$ ls<br>README<br>$ touch Viper.php<br>$ git add .<br>$ git commit -am ‘removed test.txt、add Viper.php’<br>[newtest c1501a2] removed test.txt、add Viper.php<br> 2 files changed, 1 deletion(-)<br> create mode 100644 Viper.php<br> delete mode 100644 test.txt<br>$ ls<br>README        Viper.php<br>$ git checkout master<br>Switched to branch ‘master’<br>$ ls<br>README        test.txt<br>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 Viper.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 Viper.php 不存在主分支中。</p>
<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>
<p>5.2 删除分支<br>删除分支命令：</p>
<p>git branch -d (branchname)<br>例如我们要删除 testing 分支：</p>
<p>$ git branch</p>
<ul>
<li>master<br>testing<br>$ git branch -d testing<br>Deleted branch testing (was 85fc7e7).<br>$ git branch</li>
<li>master</li>
</ul>
<p>5.3 分支合并<br>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p>
<p>git merge<br>$ git branch</p>
<ul>
<li>master<br>newtest<br>$ ls<br>README        test.txt<br>$ git merge newtest<br>Updating 3e92c19..c1501a2<br>Fast-forward<br>Viper.php | 0<br>test.txt   | 1 -<br>2 files changed, 1 deletion(-)<br>create mode 100644 Viper.php<br>delete mode 100644 test.txt<br>$ ls<br>README        Viper.php<br>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</li>
</ul>
<p>合并完后就可以删除分支:</p>
<p>$ git branch -d newtest<br>Deleted branch newtest (was c1501a2).<br>删除后， 就只剩下 master 分支了：</p>
<p>$ git branch</p>
<ul>
<li>master</li>
</ul>
<p>5.4 合并冲突<br>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>
<p>$ git branch</p>
<ul>
<li>master<br>$ cat Viper.php<br>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 Viper.php 内容改为:</li>
</ul>
<?php
echo 'Viper';
?>
<p>创建 change_site 分支：</p>
<p>$ git checkout -b change_site<br>Switched to a new branch ‘change_site’<br>$ vim Viper.php<br>$ head -3 Viper.php<br><?php
echo 'Viper';
?><br>$ git commit -am ‘changed the Viper.php’<br>[change_site 7774248] changed the Viper.php<br> 1 file changed, 3 insertions(+)<br>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的 (空文件，没有代码)，我们再次修改 Viper.php 文件。</p>
<p>$ git checkout master<br>Switched to branch ‘master’<br>$ cat Viper.php<br>$ vim Viper.php    # 修改内容如下<br>$ cat Viper.php<br><?php
echo 1;
?><br>$ git diff<br>diff –git a/Viper.php b/Viper.php<br>index e69de29..ac60739 100644<br>— a/Viper.php<br>+++ b/Viper.php<br>@@ -0,0 +1,3 @@<br>+<?php
+echo 1;
+?><br>$ git commit -am ‘修改代码’<br>[master c68142b] 修改代码<br> 1 file changed, 3 insertions(+)<br>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p>
<p>$ git merge change_site<br>Auto-merging Viper.php<br>CONFLICT (content): Merge conflict in Viper.php<br>Automatic merge failed; fix conflicts and then commit the result.</p>
<p>$ cat Viper.php     # 代开文件，看到冲突内容<br>&lt;?php<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>echo 1;<br>=======<br>echo ‘Viper’;</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>change_site<br>?&gt;<br>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>$ vim Viper.php<br>$ cat Viper.php<br><?php
echo 1;
echo 'Viper';
?><br>$ git diff<br>diff –cc Viper.php<br>index ac60739,b63d7d7..0000000<br>— a/Viper.php<br>+++ b/Viper.php<br>@@@ -1,3 -1,3 +1,4 @@@<br>  &lt;?php<br> +echo 1;</p>
<ul>
<li>echo ‘Viper’;<br>?&gt;<br>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</li>
</ul>
<p>$ git status -s<br>UU Viper.php<br>$ git add Viper.php<br>$ git status -s<br>M  Viper.php<br>$ git commit<br>[master 88afe0e] Merge branch ‘change_site’<br>现在我们成功解决了合并中的冲突，并提交了结果。</p>
<ol start="6">
<li>Git 查看提交历史<br>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</li>
</ol>
<p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p>
<p>$ git log<br>commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)<br>Merge: c68142b 7774248<br>Author: Viper <a href="mailto:&#116;&#x65;&#x73;&#x74;&#x40;&#86;&#x69;&#x70;&#101;&#114;&#x2e;&#99;&#x6f;&#x6d;">&#116;&#x65;&#x73;&#x74;&#x40;&#86;&#x69;&#x70;&#101;&#114;&#x2e;&#99;&#x6f;&#x6d;</a><br>Date:   Fri May 3 15:55:58 2019 +0800</p>
<pre><code>Merge branch &apos;change_site&apos;</code></pre><p>commit c68142b562c260c3071754623b08e2657b4c6d5b<br>Author: Viper <a href="mailto:&#116;&#x65;&#115;&#x74;&#x40;&#x56;&#105;&#x70;&#101;&#114;&#46;&#99;&#x6f;&#109;">&#116;&#x65;&#115;&#x74;&#x40;&#x56;&#105;&#x70;&#101;&#114;&#46;&#99;&#x6f;&#109;</a><br>Date:   Fri May 3 15:52:12 2019 +0800</p>
<pre><code>修改代码</code></pre><p>commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)<br>Author: Viper <a href="mailto:&#116;&#101;&#115;&#116;&#x40;&#x56;&#105;&#112;&#x65;&#114;&#46;&#x63;&#111;&#109;">&#116;&#101;&#115;&#116;&#x40;&#x56;&#105;&#112;&#x65;&#114;&#46;&#x63;&#111;&#109;</a><br>Date:   Fri May 3 15:49:26 2019 +0800</p>
<pre><code>changed the Viper.php</code></pre><p>commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00<br>Author: Viper <a href="mailto:&#116;&#x65;&#x73;&#116;&#x40;&#86;&#105;&#112;&#101;&#x72;&#x2e;&#x63;&#111;&#109;">&#116;&#x65;&#x73;&#116;&#x40;&#86;&#105;&#112;&#101;&#x72;&#x2e;&#x63;&#111;&#109;</a><br>Date:   Fri May 3 15:35:32 2019 +0800<br>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p>
<p>$ git log –oneline<br>$ git log –oneline<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>c68142b 修改代码<br>7774248 (change_site) changed the Viper.php<br>c1501a2 removed test.txt、add Viper.php<br>3e92c19 add test.txt<br>3b58100 第一次版本提交<br>这告诉我们的是，此项目的开发历史。</p>
<p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>
<ul>
<li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the Viper.php</li>
<li>| c68142b 修改代码<br>|/  </li>
<li>c1501a2 removed test.txt、add Viper.php</li>
<li>3e92c19 add test.txt</li>
<li>3b58100 第一次版本提交<br>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</li>
</ul>
<p>你也可以用 –reverse 参数来逆向显示所有日志。</p>
<p>$ git log –reverse –oneline<br>3b58100 第一次版本提交<br>3e92c19 add test.txt<br>c1501a2 removed test.txt、add Viper.php<br>7774248 (change_site) changed the Viper.php<br>c68142b 修改代码<br>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>
<p>$ git log –author=Linus –oneline -5<br>81b50f3 Move ‘builtin-*’ into a ‘builtin/‘ subdirectory<br>3bb7256 make “index-pack” a built-in<br>377d027 make “git pack-redundant” a built-in<br>b532581 make “git unpack-file” a built-in<br>112dd51 make “mktag” a built-in<br>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p>
<p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p>
<p>$ git log –oneline –before={3.weeks.ago} –after={2010-04-18} –no-merges<br>5469e2d Git 1.7.1-rc2<br>d43427d Documentation/remote-helpers: Fix typos and improve language<br>272a36b Fixup: Second argument may be any arbitrary string<br>b6c8d2d Documentation/remote-helpers: Add invocation section<br>5ce4f4e Documentation/urls: Rewrite to accomodate transport::address<br>00b84e9 Documentation/remote-helpers: Rewrite description<br>03aa87e Documentation: Describe other situations where -z affects git diff<br>77bc694 rebase-interactive: silence warning when no commits rewritten<br>636db2c t3301: add tests to use –format=”%N”<br>7. Git 标签<br>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p>
<p>比如说，我们想为我们的 Viper 项目发布一个 “1.0” 版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0” 的标签。</p>
<p>-a 选项意为 “创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p>
<p>$ git tag -a v1.0<br>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p>
<p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p>
<ul>
<li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the Viper.php</li>
<li>| c68142b 修改代码<br>|/  </li>
<li>c1501a2 removed test.txt、add Viper.php</li>
<li>3e92c19 add test.txt</li>
<li>3b58100 第一次版本提交<br>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</li>
</ul>
<p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p>
<p>$ git tag -a v0.9 85fc7e7<br>$ git log –oneline –decorate –graph</p>
<ul>
<li>d5e9fc2 (HEAD -&gt; master) Merge branch ‘change_site’<br>|\<br>| * 7774248 (change_site) changed the Viper.php</li>
<li>| c68142b 修改代码<br>|/  </li>
<li>c1501a2 removed test.txt、add Viper.php</li>
<li>3e92c19 add test.txt</li>
<li>3b58100 (tag: v0.9) 第一次版本提交<br>如果我们要查看所有标签可以使用以下命令：</li>
</ul>
<p>$ git tag<br>v0.9<br>v1.0<br>指定标签信息命令：</p>
<p>git tag -a <tagname> -m “Viper.com标签”<br>PGP 签名标签命令：</p>
<p>git tag -s <tagname> -m “Viper.com标签”<br>标签介绍<br>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p>
<p>所以，标签也是版本库的一个快照。</p>
<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git 有 commit，为什么还要引入 tag？</p>
<p>“请把上周一的那个版本打包发布，commit 号是 6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是 v1.2”</p>
<p>“好的，按照 tag v1.2 查找 commit 就行！”</p>
<p>所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p>
<p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。</p>
<p>本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。</p>
<p>整合步骤<br>1 新建标签<br>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p>
<p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。</p>
<p>而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。</p>
<p>一般我们都建议使用含附注型的标签，以便保留相关信息；</p>
<p>当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<p>2 创建标签<br>[root@Git git]# git tag v1.0<br>3 查看已有标签<br>[root@Git git]# git tag<br>v1.0<br>[root@Git git]# git tag v1.1<br>[root@Git git]# git tag<br>v1.0<br>v1.1<br>4 删除标签<br>[root@Git git]# git tag -d v1.1<br>Deleted tag ‘v1.1’ (was 91388f0)<br>[root@Git git]# git tag<br>v1.0<br>5 查看此版本所修改的内容<br>[root@Git git]# git show v1.0<br>commit 91388f0883903ac9014e006611944f6688170ef4<br>Author: “syaving” &lt;”<a href="mailto:819044347@qq.com">819044347@qq.com</a>“&gt;<br>Date: Fri Dec 16 02:32:05 2016 +0800<br>commit dir<br>diff –git a/readme b/readme<br>index 7a3d711..bfecb47 100644<br>— a/readme<br>+++ b/readme<br>@@ -1,2 +1,3 @@<br>text<br>hello git<br>+use commit<br>[root@Git git]# git log –oneline<br>91388f0 commit dir<br>e435fe8 add readme<br>2525062 add readme<br>8. Git 远程仓库 (Github)<br>Git 并不像 SVN 那样有个中心服务器。</p>
<p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p>
<p>8.1 添加远程库<br>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用, 命令格式如下：</p>
<p>git remote add [shortname] [url]<br>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a> / 注册。</p>
<p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息：</p>
<p>使用以下命令生成 SSH Key：</p>
<p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com">youremail@example.com</a>“<br>后面的 <a href="mailto:your_email@youremail.com">your_email@youremail.com</a> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。</p>
<p>回到 github 上，进入 Account =&gt; Settings（账户配置）。</p>
<p>左边选择 SSH and GPG keys，然后点击 New SSH key 按钮, title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p>
<p>添加成功后界面如下所示</p>
<p>为了验证是否成功，输入以下命令：</p>
<p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Hi tianqixin! You’ve successfully authenticated, but GitHub does not provide shell access.<br>以下命令说明我们已成功连上 Github。</p>
<p>之后登录后点击 “New repository” 如下图所示：</p>
<p>之后在在 Repository name 填入 Viper-git-test(远程仓库名) ，其他保持默认设置，点击 “Create repository” 按钮，就成功地创建了一个新的 Git 仓库：</p>
<p>创建成功后，显示如下信息：</p>
<p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p>
<p>$ mkdir Viper-git-test                     # 创建测试目录<br>$ cd Viper-git-test/                       # 进入测试目录<br>$ echo “# 菜鸟教程 Git 测试” &gt;&gt; README.md     # 创建 README.md 文件并写入内容<br>$ ls                                        # 查看目录下的文件<br>README<br>$ git init                                  # 初始化<br>$ git add README.md                         # 添加文件<br>$ git commit -m “添加 README.md 文件”        # 提交并备注信息<br>[master (root-commit) 0205aab] 添加 README.md 文件<br> 1 file changed, 1 insertion(+)<br> create mode 100644 README.md</p>
<h1 id="提交到-Github"><a href="#提交到-Github" class="headerlink" title="提交到 Github"></a>提交到 Github</h1><p>$ git remote add origin <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git<br>$ git push -u origin master<br>以下命令请根据你在 Github 成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的 Github 用户名不一样，仓库名也不一样。</p>
<p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github 上：</p>
<p>8.2 查看当前的远程库<br>要查看当前配置有哪些远程仓库，可以用命令：</p>
<p>git remote<br>实例<br>$ git remote<br>origin<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)<br>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</p>
<p>8.3 提取远程仓库<br>Git 有两个命令用来提取远程仓库的更新。</p>
<p>1、从远程仓库下载新分支与数据：</p>
<p>git fetch<br>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p>
<p>2、从远端仓库提取数据并尝试合并到当前分支：</p>
<p>git merge<br>该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</p>
<p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p>
<p>接下来我们在 Github 上点击 “README.md” 并在线修改它:</p>
<p>然后我们在本地更新修改。</p>
<p>$ git fetch origin<br>remote: Counting objects: 3, done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3/3), done.<br>From github.com:tianqixin/Viper-git-test<br>   0205aab..febd8ed  master     -&gt; origin/master<br>以上信息 “0205aab…febd8ed master -&gt; origin/master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：</p>
<p>$ git merge origin/master<br>Updating 0205aab..febd8ed<br>Fast-forward<br> README.md | 1 +<br> 1 file changed, 1 insertion(+)<br>查看 README.md 文件内容：</p>
<p>$ cat README.md </p>
<h1 id="菜鸟教程-Git-测试"><a href="#菜鸟教程-Git-测试" class="headerlink" title="菜鸟教程 Git 测试"></a>菜鸟教程 Git 测试</h1><h2 id="第一次修改内容"><a href="#第一次修改内容" class="headerlink" title="第一次修改内容"></a>第一次修改内容</h2><p>8.4 推送到远程仓库<br>推送你的新分支与数据到某个远端仓库命令:</p>
<p>git push [alias] [branch]<br>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p>
<p>$ touch Viper-test.txt      # 添加文件<br>$ git add Viper-test.txt<br>$ git commit -m “添加到远程”<br>master 69e702d] 添加到远程<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 Viper-test.txt</p>
<p>$ git push origin master    # 推送到 Github<br>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p>
<p>8.5 删除远程仓库<br>删除远程仓库你可以使用命令：</p>
<p>git remote rm [别名]<br>实例<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)</p>
<h1 id="添加仓库-origin2"><a href="#添加仓库-origin2" class="headerlink" title="添加仓库 origin2"></a>添加仓库 origin2</h1><p>$ git remote add origin2 <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git</p>
<p>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin2    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)</p>
<h1 id="删除仓库-origin2"><a href="#删除仓库-origin2" class="headerlink" title="删除仓库 origin2"></a>删除仓库 origin2</h1><p>$ git remote rm origin2<br>$ git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git (push)<br>执行 git fetch origin master 时，它的意思是从名为 origin 的远程上拉取名为 master 的分支到本地分支 origin/master 中。既然是拉取代码，当然需要同时指定远程名与分支名，所以分开写。<br>执行 git merge origin/master 时，它的意思是合并名为 origin/master 的分支到当前所在分支。既然是分支的合并，当然就与远程名没有直接的关系，所以没有出现远程名。需要指定的是被合并的分支。<br>执行 git push origin master 时，它的意思是推送本地的 master 分支到远程 origin，涉及到远程以及分支，当然也得分开写了。<br>还可以一次性拉取多个分支的代码：git fetch origin master stable oldstable；<br>也还可以一次性合并多个分支的代码：git merge origin/master hotfix-2275 hotfix-2276 hotfix-2290；<br>常见问题</p>
<p>ssh 访问 gitHub 出错如下：</p>
<p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>The authenticity of host ‘github.com (140.82.118.4)’ can’t be established.<br>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want to continue connecting (yes/no)?<br>Host key verification failed.<br>解决办法：（将 GitHub 添加到信任主机列表后，可以成功访问）</p>
<p>$ ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts</p>
<h1 id="github-com-22-SSH-2-0-babeld-d45c1532"><a href="#github-com-22-SSH-2-0-babeld-d45c1532" class="headerlink" title="github.com:22 SSH-2.0-babeld-d45c1532"></a>github.com:22 SSH-2.0-babeld-d45c1532</h1><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>Warning: Permanently added the RSA host key for IP address ‘140.82.118.4’ to the list of known hosts.<br>Hi earthnorth! You’ve successfully authenticated, but GitHub does not provide shell access.<br>9. Git Gitee<br>大家都知道国内访问 Github 速度比较慢，很影响我们的使用。</p>
<p>如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）。</p>
<p>Gitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。</p>
<p>接下来我们学习一下如何使用 Gitee。</p>
<p>由于我们的本地 Git 仓库和 Gitee 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息。</p>
<p>1、我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥。</p>
<p>我们在 Git Github 章节已经生成了自己的 SSH 公钥，所以我们只需要将用户主目录下的 ~/.ssh/id_rsa.pub 文件的内容粘贴 Gitee 上。</p>
<p>选择右上角用户头像 -&gt; 设置，然后选择 “SSH 公钥”，填写一个便于识别的标题，然后把用户主目录下的 .ssh/id_rsa.pub 文件的内容粘贴进去：</p>
<p>成功添加后如下图所示：</p>
<p>接下来我们创建一个项目。</p>
<p>点击右上角的 + 号，新建仓库：</p>
<p>然后添加仓库信息：</p>
<p>创建成功后看到如下信息：</p>
<p>接下来我们看下连接信息：</p>
<p>项目名称最好与本地库保持一致。</p>
<p>然后，我们在本地库上使用命令 git remote add 把它和 Gitee 的远程库关联：</p>
<p>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>之后，就可以正常地用 git push 和 git pull 推送了！</p>
<p>如果在使用命令 git remote add 时报错：</p>
<p>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>fatal: remote origin already exists.<br>这说明本地库已经关联了一个名叫 origin 的远程库，此时，可以先用 git remote -v 查看远程库信息：</p>
<p>git remote -v<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (fetch)<br>origin    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (push)<br>可以看到，本地库已经关联了 origin 的远程库，并且，该远程库指向 GitHub。</p>
<p>我们可以删除已有的 GitHub 远程库：</p>
<p>git remote rm origin<br>再关联 Gitee 的远程库（注意路径中需要填写正确的用户名）：</p>
<p>git remote add origin <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>此时，我们再查看远程库信息：</p>
<p>git remote -v<br>origin    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (fetch)<br>origin    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (push)<br>现在可以看到，origin 已经被关联到 Gitee 的远程库了。</p>
<p>通过 git push 命令就可以把本地库推送到 Gitee 上。</p>
<p>有的小伙伴又要问了，一个本地库能不能既关联 GitHub，又关联 Gitee 呢？</p>
<p>答案是肯定的，因为 git 本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以 Viper-test 本地库为例，我们先删除已关联的名为 origin 的远程库：</p>
<p>git remote rm origin<br>然后，先关联 GitHub 的远程库：</p>
<p>git remote add github <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper-git-test.git<br>注意，远程库的名称叫 github，不叫 origin 了。</p>
<p>接着，再关联 Gitee 的远程库：</p>
<p>git remote add gitee <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git<br>同样注意，远程库的名称叫 gitee，不叫 origin。</p>
<p>现在，我们用 git remote -v 查看远程库信息，可以看到两个远程库：</p>
<p>git remote -v<br>gitee    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (fetch)<br>gitee    <a href="mailto:git@gitee.com">git@gitee.com</a>:imnoob/Viper-test.git (push)<br>github    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (fetch)<br>github    <a href="mailto:git@github.com">git@github.com</a>:tianqixin/Viper.git (push)<br>如果要推送到 GitHub，使用命令：</p>
<p>git push github master<br>如果要推送到 Gitee，使用命令：</p>
<p>git push gitee master<br>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p>
<p>10.Git 服务器搭建<br>上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。</p>
<p>这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。</p>
<p>接下来我们将以 Centos 为例搭建 Git 服务器。</p>
<p>1、安装 Git<br>$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel<br>$ yum install git<br>接下来我们 创建一个 git 用户组和用户，用来运行 git 服务：</p>
<p>$ groupadd git<br>$ useradd git -g git<br>2、创建证书登录<br>收集所有需要登录的用户的公钥，公钥位于 id_rsa.pub 文件中，把我们的公钥导入到 / home/git/.ssh/authorized_keys 文件里，一行一个。</p>
<p>如果没有该文件创建它：</p>
<p>$ cd /home/git/<br>$ mkdir .ssh<br>$ chmod 755 .ssh<br>$ touch .ssh/authorized_keys<br>$ chmod 644 .ssh/authorized_keys<br>3、初始化 Git 仓库<br>首先我们选定一个目录作为 Git 仓库，假定是 / home/gitrepo/Viper.git，在 / home/gitrepo 目录下输入命令：</p>
<p>$ cd /home<br>$ mkdir gitrepo<br>$ chown git:git gitrepo/<br>$ cd gitrepo</p>
<p>$ git init –bare Viper.git<br>Initialized empty Git repository in /home/gitrepo/Viper.git/<br>以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以. git 结尾。然后，把仓库所属用户改为 git：</p>
<p>$ chown -R git:git Viper.git<br>4、克隆仓库<br>$ git clone <a href="mailto:git@192.168.45.4">git@192.168.45.4</a>:/home/gitrepo/Viper.git<br>Cloning into ‘Viper’…<br>warning: You appear to have cloned an empty repository.<br>Checking connectivity… done.<br>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
<p>总结<br>这篇 Git 命令并不是特别的全，不过日常使用也基本能够满足了。如果有什么错误，麻烦各位在评论区指正，看见后会修改的。感觉文章不错的话点个收藏，关注我，持续更新不同高质量文章！</p>
<p>全文完<br>本文由 简悦 SimpRead 优化，用以提升阅读体验<br>使用了 全新的简悦词法分析引擎 beta，点击查看详细说明<br>前言<br>1.Git 安装配置<br>1…1Linux 平台上安装<br>Debian/Ubuntu<br>Centos/RedHat<br>源码安装<br>1.2 Windows 平台上安装<br>1.3Mac 平台上安装<br>1.4 Git 配置<br>用户信息<br>文本编辑器<br>差异分析工具<br>查看配置信息<br>2.Git 创建仓库<br>git init<br>使用方法<br>git clone<br>3. Git 基本操作<br>3.1 获取与创建项目命令<br>git init<br>git clone<br>3.2 基本快照<br>git add<br>git status<br>git diff<br>git commit<br>git reset HEAD<br>git rm<br>git mv<br>4. 再按照作用重新整理一下命令<br>一、Git 配置相关<br>二、本地基本操作<br>4、其他<br>三、加塞临时任务处理<br>四、修改个人分支历史<br>五、查看变更日志等<br>六、分支与标签<br>七、两分支之间的集成<br>八、和远端交互<br>九、常用回滚操作系统<br>5. Git 分支管理<br>5.1 列出分支<br>5.2 删除分支<br>5.3 分支合并<br>5.4 合并冲突<br>6. Git 查看提交历史<br>7. Git 标签<br>标签介绍<br>整合步骤<br>1 新建标签<br>2 创建标签<br>3 查看已有标签<br>4 删除标签<br>5 查看此版本所修改的内容<br>8. Git 远程仓库 (Github)<br>8.1 添加远程库<br>8.2 查看当前的远程库<br>实例<br>8.3 提取远程仓库<br>8.4 推送到远程仓库<br>8.5 删除远程仓库<br>实例<br>9. Git Gitee<br>10.Git 服务器搭建<br>1、安装 Git<br>2、创建证书登录<br>3、初始化 Git 仓库<br>4、克隆仓库<br>总结<br>共计：32030 个字符，汉字：9161，段落：1102，英文单词：3932</p>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">别扫了,别扫了</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/06/22/%E9%98%B2%E8%8C%83gsm%E7%9F%AD%E4%BF%A1%E5%97%85%E6%8E%A2/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2020/08/11/%E4%BC%9A%E5%B8%83%E5%B1%80%E7%9A%84%E4%BA%BA%E6%89%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%AB%98%E6%89%8B/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
